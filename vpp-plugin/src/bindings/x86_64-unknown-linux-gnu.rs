/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const CLIB_LOG2_CACHE_LINE_BYTES: u32 = 6;
pub const CLIB_LIB_DIR: &[u8; 21] = b"lib/x86_64-linux-gnu\0";
pub const CLIB_VECTOR_GROW_BY_ONE: u32 = 0;
pub const CLIB_MAX_MHEAPS: u32 = 256;
pub const CLIB_MAX_NUMAS: u32 = 16;
pub const CLIB_MEM_ERROR: i32 = -1;
pub const CLIB_MEM_LOG2_MIN_ALIGN: u32 = 3;
pub const CLIB_MEM_MIN_ALIGN: u32 = 8;
pub const CLIB_VM_MAP_HDR_NAME_MAX_LEN: u32 = 64;
pub const VEC_NUMA_UNSPECIFIED: u32 = 255;
pub const VEC_MIN_ALIGN: u32 = 8;
pub const UNFORMAT_END_OF_INPUT: i32 = -1;
pub const UNFORMAT_MORE_INPUT: u32 = 0;
pub const VLIB_BUFFER_PRE_DATA_SIZE: u32 = 128;
pub const VLIB_BUFFER_ALIGN: u32 = 64;
pub const VLIB_BUFFER_ALLOC_FAULT_INJECTOR: u32 = 0;
pub const VLIB_PROCESS_LOG2_STACK_SIZE: u32 = 15;
pub const VLIB_BUFFER_DEFAULT_DATA_SIZE: u32 = 2048;
pub const VLIB_BUFFER_MIN_CHAIN_SEG_SIZE: u32 = 128;
pub const VLIB_BUFFER_CLONE_HEAD_SIZE: u32 = 256;
pub const VLIB_BUFFER_FLAGS_ALL: u32 = 15;
pub const VLIB_BUFFER_TRACE_TRAJECTORY: u32 = 0;
pub const VLIB_BUFFER_TRACE_TRAJECTORY_SZ: u32 = 0;
pub const VLIB_BUFFER_INVALID_INDEX: u32 = 4294967295;
pub const VLIB_BUFFER_POOL_PER_THREAD_CACHE_SZ: u32 = 512;
pub const VLIB_BUFFER_MAX_NUMA_NODES: u32 = 32;
pub const CLIB_MARCH_VARIANT_STR: &[u8; 8] = b"default\0";
pub const VLIB_NODE_FLAG_FRAME_NO_FREE_AFTER_DISPATCH: u32 = 1;
pub const VLIB_NODE_FLAG_IS_OUTPUT: u32 = 2;
pub const VLIB_NODE_FLAG_IS_DROP: u32 = 4;
pub const VLIB_NODE_FLAG_IS_PUNT: u32 = 8;
pub const VLIB_NODE_FLAG_IS_HANDOFF: u32 = 16;
pub const VLIB_NODE_FLAG_TRACE: u32 = 32;
pub const VLIB_NODE_FLAG_SWITCH_FROM_INTERRUPT_TO_POLLING_MODE: u32 = 64;
pub const VLIB_NODE_FLAG_SWITCH_FROM_POLLING_TO_INTERRUPT_MODE: u32 = 128;
pub const VLIB_NODE_FLAG_TRACE_SUPPORTED: u32 = 256;
pub const VLIB_NODE_FLAG_ADAPTIVE_MODE: u32 = 512;
pub const VLIB_NODE_FLAG_ALLOW_LAZY_NEXT_NODES: u32 = 1024;
pub const VLIB_FRAME_SIZE: u32 = 256;
pub const VLIB_FRAME_SIZE_EXTRA: u32 = 4;
pub const VLIB_FRAME_DATA_ALIGN: u32 = 16;
pub const VLIB_FRAME_NO_FREE_AFTER_DISPATCH: u32 = 1;
pub const VLIB_FRAME_NO_APPEND: u32 = 16384;
pub const VLIB_FRAME_OWNER: u32 = 32768;
pub const VLIB_FRAME_IS_ALLOCATED: u32 = 2;
pub const VLIB_FRAME_PENDING: u32 = 4;
pub const VLIB_FRAME_FREE_AFTER_DISPATCH: u32 = 8;
pub const VLIB_FRAME_TRACE: u32 = 32;
pub const VLIB_PROCESS_RESUME_LONGJMP_SUSPEND: u32 = 0;
pub const VLIB_PROCESS_RESUME_LONGJMP_RESUME: u32 = 1;
pub const VLIB_PROCESS_STACK_MAGIC: u32 = 3735912109;
pub const VLIB_NODE_MAIN_RUNTIME_STARTED: u32 = 1;
pub const FRAME_QUEUE_MAX_NELTS: u32 = 64;
pub const VLIB_ELOG_MAIN_LOOP: u32 = 0;
pub const VLIB_LOG2_MAIN_LOOPS_PER_STATS_UPDATE: u32 = 7;
pub const VLIB_MAIN_LOOP_EXIT_NONE: u32 = 0;
pub const VLIB_MAIN_LOOP_EXIT_PANIC: u32 = 1;
pub const VLIB_MAIN_LOOP_EXIT_CLI: u32 = 2;
pub const VLIB_BUFFER_LINEARIZE_MAX: u32 = 64;
pub const VNET_REWRITE_TOTAL_BYTES: u32 = 128;
pub const VL_API_LITTLE_ENDIAN: u32 = 0;
pub const VL_API_BIG_ENDIAN: u32 = 1;
pub const VL_SHM_VERSION: u32 = 2;
pub const VL_API_EPOCH_MASK: u32 = 255;
pub const VL_API_EPOCH_SHIFT: u32 = 8;
pub type i8_ = ::std::os::raw::c_schar;
pub type i16_ = ::std::os::raw::c_short;
pub type u8_ = ::std::os::raw::c_uchar;
pub type u16_ = ::std::os::raw::c_ushort;
pub type i32_ = ::std::os::raw::c_int;
pub type i64_ = ::std::os::raw::c_long;
pub type u32_ = ::std::os::raw::c_uint;
pub type u64_ = ::std::os::raw::c_ulong;
pub type word = i64_;
pub type uword = u64_;
pub type any = word;
pub type f64_ = f64;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CLIB_ERROR_FATAL: _bindgen_ty_29 = 1;
pub const CLIB_ERROR_ABORT: _bindgen_ty_29 = 2;
pub const CLIB_ERROR_WARNING: _bindgen_ty_29 = 4;
pub const CLIB_ERROR_ERRNO_VALID: _bindgen_ty_29 = 65536;
pub const CLIB_ERROR_NO_RATE_LIMIT: _bindgen_ty_29 = 131072;
pub type _bindgen_ty_29 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn _clib_error(
        code: ::std::os::raw::c_int,
        function_name: *const ::std::os::raw::c_char,
        line_number: uword,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
pub type va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clib_error_t {
    pub what: *mut u8_,
    pub where_: *const u8_,
    pub flags: uword,
    pub code: any,
}
impl Default for clib_error_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type u64x2 = [u64_; 2usize];
pub const clib_mem_page_sz_t_CLIB_MEM_PAGE_SZ_UNKNOWN: clib_mem_page_sz_t = 0;
pub const clib_mem_page_sz_t_CLIB_MEM_PAGE_SZ_DEFAULT: clib_mem_page_sz_t = 1;
pub const clib_mem_page_sz_t_CLIB_MEM_PAGE_SZ_DEFAULT_HUGE: clib_mem_page_sz_t = 2;
pub const clib_mem_page_sz_t_CLIB_MEM_PAGE_SZ_4K: clib_mem_page_sz_t = 12;
pub const clib_mem_page_sz_t_CLIB_MEM_PAGE_SZ_16K: clib_mem_page_sz_t = 14;
pub const clib_mem_page_sz_t_CLIB_MEM_PAGE_SZ_64K: clib_mem_page_sz_t = 16;
pub const clib_mem_page_sz_t_CLIB_MEM_PAGE_SZ_1M: clib_mem_page_sz_t = 20;
pub const clib_mem_page_sz_t_CLIB_MEM_PAGE_SZ_2M: clib_mem_page_sz_t = 21;
pub const clib_mem_page_sz_t_CLIB_MEM_PAGE_SZ_16M: clib_mem_page_sz_t = 24;
pub const clib_mem_page_sz_t_CLIB_MEM_PAGE_SZ_32M: clib_mem_page_sz_t = 25;
pub const clib_mem_page_sz_t_CLIB_MEM_PAGE_SZ_512M: clib_mem_page_sz_t = 29;
pub const clib_mem_page_sz_t_CLIB_MEM_PAGE_SZ_1G: clib_mem_page_sz_t = 30;
pub const clib_mem_page_sz_t_CLIB_MEM_PAGE_SZ_16G: clib_mem_page_sz_t = 34;
pub type clib_mem_page_sz_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _clib_mem_vm_map_hdr {
    pub base_addr: uword,
    pub num_pages: uword,
    pub log2_page_sz: clib_mem_page_sz_t,
    pub fd: ::std::os::raw::c_int,
    pub name: [::std::os::raw::c_char; 64usize],
    pub prev: *mut _clib_mem_vm_map_hdr,
    pub next: *mut _clib_mem_vm_map_hdr,
}
impl Default for _clib_mem_vm_map_hdr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type clib_mem_vm_map_hdr_t = _clib_mem_vm_map_hdr;
pub const clib_mem_heap_flag_t_CLIB_MEM_HEAP_F_LOCKED: clib_mem_heap_flag_t = 1;
pub const clib_mem_heap_flag_t_CLIB_MEM_HEAP_F_UNMAP_ON_DESTROY: clib_mem_heap_flag_t = 2;
pub const clib_mem_heap_flag_t_CLIB_MEM_HEAP_F_TRACED: clib_mem_heap_flag_t = 4;
pub type clib_mem_heap_flag_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct clib_mem_heap_t<FAM: ?Sized = [::std::os::raw::c_char; 0]> {
    pub base: *mut ::std::os::raw::c_void,
    pub mspace: *mut ::std::os::raw::c_void,
    pub size: uword,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub name: FAM,
}
impl clib_mem_heap_t<[::std::os::raw::c_char]> {}
impl clib_mem_heap_t<[::std::os::raw::c_char; 0]> {}
impl Default for clib_mem_heap_t<[::std::os::raw::c_char; 0]> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl clib_mem_heap_t<[::std::os::raw::c_char; 0]> {
    #[inline]
    pub fn log2_page_sz(&self) -> clib_mem_page_sz_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_log2_page_sz(&mut self, val: clib_mem_page_sz_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log2_page_sz_raw(this: *const Self) -> clib_mem_page_sz_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_log2_page_sz_raw(this: *mut Self, val: clib_mem_page_sz_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn flags(&self) -> clib_mem_heap_flag_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: clib_mem_heap_flag_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn flags_raw(this: *const Self) -> clib_mem_heap_flag_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_flags_raw(this: *mut Self, val: clib_mem_heap_flag_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        log2_page_sz: clib_mem_page_sz_t,
        flags: clib_mem_heap_flag_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let log2_page_sz: u32 = unsafe { ::std::mem::transmute(log2_page_sz) };
            log2_page_sz as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clib_mem_main_t {
    pub log2_page_sz: clib_mem_page_sz_t,
    pub log2_default_hugepage_sz: clib_mem_page_sz_t,
    pub log2_sys_default_hugepage_sz: clib_mem_page_sz_t,
    pub numa_node_bitmap: u32_,
    pub per_cpu_mheaps: [*mut ::std::os::raw::c_void; 256usize],
    pub per_numa_mheaps: [*mut ::std::os::raw::c_void; 16usize],
    pub first_map: *mut clib_mem_vm_map_hdr_t,
    pub last_map: *mut clib_mem_vm_map_hdr_t,
    pub map_lock: u8_,
    pub error: *mut clib_error_t,
}
impl Default for clib_mem_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub static mut clib_mem_main: clib_mem_main_t;
}
unsafe extern "C" {
    pub fn clib_mem_alloc(size: uword) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_alloc_aligned(size: uword, align: uword) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_alloc_or_null(size: uword) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_alloc_aligned_or_null(size: uword, align: uword)
    -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_realloc(
        p: *mut ::std::os::raw::c_void,
        new_size: uword,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_realloc_aligned(
        p: *mut ::std::os::raw::c_void,
        new_size: uword,
        align: uword,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_is_heap_object(p: *mut ::std::os::raw::c_void) -> uword;
}
unsafe extern "C" {
    pub fn clib_mem_free(p: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn clib_mem_heap_alloc(
        heap: *mut ::std::os::raw::c_void,
        size: uword,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_heap_alloc_aligned(
        heap: *mut ::std::os::raw::c_void,
        size: uword,
        align: uword,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_heap_alloc_or_null(
        heap: *mut ::std::os::raw::c_void,
        size: uword,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_heap_alloc_aligned_or_null(
        heap: *mut ::std::os::raw::c_void,
        size: uword,
        align: uword,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_heap_realloc(
        heap: *mut ::std::os::raw::c_void,
        p: *mut ::std::os::raw::c_void,
        new_size: uword,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_heap_realloc_aligned(
        heap: *mut ::std::os::raw::c_void,
        p: *mut ::std::os::raw::c_void,
        new_size: uword,
        align: uword,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_heap_is_heap_object(
        heap: *mut ::std::os::raw::c_void,
        p: *mut ::std::os::raw::c_void,
    ) -> uword;
}
unsafe extern "C" {
    pub fn clib_mem_heap_free(heap: *mut ::std::os::raw::c_void, p: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn clib_mem_size(p: *mut ::std::os::raw::c_void) -> uword;
}
unsafe extern "C" {
    pub fn clib_mem_free_s(p: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn clib_mem_destroy_heap(heap: *mut clib_mem_heap_t);
}
unsafe extern "C" {
    pub fn clib_mem_create_heap(
        base: *mut ::std::os::raw::c_void,
        size: uword,
        is_locked: ::std::os::raw::c_int,
        fmt: *mut ::std::os::raw::c_char,
        ...
    ) -> *mut clib_mem_heap_t;
}
unsafe extern "C" {
    pub fn clib_mem_main_init();
}
unsafe extern "C" {
    pub fn clib_mem_init(
        base: *mut ::std::os::raw::c_void,
        size: uword,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_init_with_page_size(
        memory_size: uword,
        log2_page_sz: clib_mem_page_sz_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_init_thread_safe(
        memory: *mut ::std::os::raw::c_void,
        memory_size: uword,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_exit();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mheap_trace_t {
    pub callers: [*mut ::std::os::raw::c_void; 12usize],
    pub n_allocations: u32_,
    pub n_bytes: u32_,
    pub offset: uword,
}
impl Default for mheap_trace_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn clib_mem_trace(enable: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn clib_mem_is_traced() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clib_mem_trace_dup(heap: *mut clib_mem_heap_t) -> *mut mheap_trace_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct clib_mem_usage_t {
    pub object_count: uword,
    pub bytes_total: uword,
    pub bytes_used: uword,
    pub bytes_free: uword,
    pub bytes_overhead: uword,
    pub bytes_free_reclaimed: uword,
    pub bytes_used_sbrk: uword,
    pub bytes_used_mmap: uword,
    pub bytes_max: uword,
}
unsafe extern "C" {
    pub fn clib_mem_get_heap_usage(heap: *mut clib_mem_heap_t, usage: *mut clib_mem_usage_t);
}
unsafe extern "C" {
    pub fn clib_mem_get_heap_base(heap: *mut clib_mem_heap_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_get_heap_size(heap: *mut clib_mem_heap_t) -> uword;
}
unsafe extern "C" {
    pub fn clib_mem_get_heap_free_space(heap: *mut clib_mem_heap_t) -> uword;
}
unsafe extern "C" {
    pub fn format_clib_mem_usage(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_clib_mem_heap(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_clib_mem_page_stats(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn clib_mem_vm_map_internal(
        base: *mut ::std::os::raw::c_void,
        log2_page_sz: clib_mem_page_sz_t,
        size: uword,
        fd: ::std::os::raw::c_int,
        offset: uword,
        name: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_vm_map(
        start: *mut ::std::os::raw::c_void,
        size: uword,
        log2_page_size: clib_mem_page_sz_t,
        fmt: *mut ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_vm_map_stack(
        size: uword,
        log2_page_size: clib_mem_page_sz_t,
        fmt: *mut ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_vm_map_shared(
        start: *mut ::std::os::raw::c_void,
        size: uword,
        fd: ::std::os::raw::c_int,
        offset: uword,
        fmt: *mut ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_vm_unmap(base: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clib_mem_vm_get_next_map_hdr(
        hdr: *mut clib_mem_vm_map_hdr_t,
    ) -> *mut clib_mem_vm_map_hdr_t;
}
unsafe extern "C" {
    pub fn clib_mem_vm_create_fd(
        log2_page_size: clib_mem_page_sz_t,
        fmt: *mut ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clib_mem_get_fd_page_size(fd: ::std::os::raw::c_int) -> uword;
}
unsafe extern "C" {
    pub fn clib_mem_get_fd_log2_page_size(fd: ::std::os::raw::c_int) -> clib_mem_page_sz_t;
}
unsafe extern "C" {
    pub fn clib_mem_vm_reserve(
        start: uword,
        size: uword,
        log2_page_sz: clib_mem_page_sz_t,
    ) -> uword;
}
unsafe extern "C" {
    pub fn clib_mem_vm_get_paddr(
        mem: *mut ::std::os::raw::c_void,
        log2_page_size: clib_mem_page_sz_t,
        n_pages: ::std::os::raw::c_int,
    ) -> *mut u64_;
}
unsafe extern "C" {
    pub fn clib_mem_destroy();
}
unsafe extern "C" {
    pub fn clib_mem_set_numa_affinity(
        numa_node: u8_,
        force: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clib_mem_set_default_numa_affinity() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clib_mem_vm_randomize_va(requested_va: *mut uword, log2_page_size: clib_mem_page_sz_t);
}
unsafe extern "C" {
    pub fn mheap_trace(v: *mut clib_mem_heap_t, enable: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn clib_mem_trace_enable_disable(enable: uword) -> uword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clib_mem_page_stats_t {
    pub log2_page_sz: clib_mem_page_sz_t,
    pub total: uword,
    pub mapped: uword,
    pub not_mapped: uword,
    pub per_numa: [uword; 16usize],
    pub unknown: uword,
}
impl Default for clib_mem_page_stats_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn clib_mem_get_page_stats(
        start: *mut ::std::os::raw::c_void,
        log2_page_size: clib_mem_page_sz_t,
        n_pages: uword,
        stats: *mut clib_mem_page_stats_t,
    );
}
pub type clib_mem_bulk_handle_t = *mut ::std::os::raw::c_void;
unsafe extern "C" {
    pub fn clib_mem_bulk_init(
        elt_sz: u32_,
        align: u32_,
        min_elts_per_chunk: u32_,
    ) -> clib_mem_bulk_handle_t;
}
unsafe extern "C" {
    pub fn clib_mem_bulk_destroy(h: clib_mem_bulk_handle_t);
}
unsafe extern "C" {
    pub fn clib_mem_bulk_alloc(h: clib_mem_bulk_handle_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn clib_mem_bulk_free(h: clib_mem_bulk_handle_t, p: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn format_clib_mem_bulk(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct vec_header_t<FAM: ?Sized = [u8_; 0]> {
    pub len: u32_,
    pub hdr_size: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub grow_elts: u8_,
    pub vpad: [u8_; 1usize],
    pub vector_data: FAM,
}
impl vec_header_t<[u8_]> {}
impl vec_header_t<[u8_; 0]> {}
impl vec_header_t<[u8_; 0]> {
    #[inline]
    pub fn log2_align(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_log2_align(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn log2_align_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_log2_align_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn default_heap(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_default_heap(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn default_heap_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_default_heap_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        log2_align: u8_,
        default_heap: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let log2_align: u8 = unsafe { ::std::mem::transmute(log2_align) };
            log2_align as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let default_heap: u8 = unsafe { ::std::mem::transmute(default_heap) };
            default_heap as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub fn vec_len_not_inline(v: *mut ::std::os::raw::c_void) -> u32_;
}
unsafe extern "C" {
    pub fn vec_mem_size(v: *mut ::std::os::raw::c_void) -> uword;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vec_attr_t {
    pub heap: *mut ::std::os::raw::c_void,
    pub elt_sz: u32_,
    pub hdr_sz: u16_,
    pub align: u16_,
}
impl Default for vec_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn _vec_alloc_internal(
        n_elts: uword,
        attr: *const vec_attr_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _vec_realloc_internal(
        v: *mut ::std::os::raw::c_void,
        n_elts: uword,
        attr: *const vec_attr_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _vec_resize_internal(
        v: *mut ::std::os::raw::c_void,
        n_elts: uword,
        attr: *const vec_attr_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vec_free_not_inline(v: *mut ::std::os::raw::c_void);
}
pub type clib_error_handler_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        msg: *mut u8_,
        msg_len: ::std::os::raw::c_int,
    ),
>;
unsafe extern "C" {
    pub fn clib_error_register_handler(
        func: clib_error_handler_func_t,
        arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn clib_error_free_vector(errors: *mut clib_error_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn _clib_error_return(
        errors: *mut clib_error_t,
        code: any,
        flags: uword,
        where_: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn _clib_error_report(errors: *mut clib_error_t) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn format_clib_error(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct clib_spinlock_s {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub lock: u32_,
}
impl Default for clib_spinlock_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type clib_spinlock_t = *mut clib_spinlock_s;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_null: pcap_packet_type_t = 0;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_ethernet: pcap_packet_type_t = 1;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_ppp: pcap_packet_type_t = 9;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_ip: pcap_packet_type_t = 12;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_hdlc: pcap_packet_type_t = 104;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user0: pcap_packet_type_t = 147;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user1: pcap_packet_type_t = 148;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user2: pcap_packet_type_t = 149;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user3: pcap_packet_type_t = 150;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user4: pcap_packet_type_t = 151;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user5: pcap_packet_type_t = 152;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user6: pcap_packet_type_t = 153;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user7: pcap_packet_type_t = 154;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user8: pcap_packet_type_t = 155;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user9: pcap_packet_type_t = 156;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user10: pcap_packet_type_t = 157;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user11: pcap_packet_type_t = 158;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user12: pcap_packet_type_t = 159;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user13: pcap_packet_type_t = 160;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user14: pcap_packet_type_t = 161;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_user15: pcap_packet_type_t = 162;
pub const pcap_packet_type_t_PCAP_PACKET_TYPE_vpp: pcap_packet_type_t = 280;
pub type pcap_packet_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcap_main_t {
    pub lock: clib_spinlock_t,
    pub file_name: *mut ::std::os::raw::c_char,
    pub n_packets_to_capture: u32_,
    pub packet_type: pcap_packet_type_t,
    pub n_packets_captured: u32_,
    pub flags: u32_,
    pub file_descriptor: ::std::os::raw::c_int,
    pub n_pcap_data_written: u32_,
    pub pcap_data: *mut u8_,
    pub packets_read: *mut *mut u8_,
    pub timestamps: *mut u64_,
    pub min_packet_bytes: u32_,
    pub max_packet_bytes: u32_,
}
impl Default for pcap_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type format_function_t =
    ::std::option::Option<unsafe extern "C" fn(s: *mut u8_, args: *mut va_list) -> *mut u8_>;
unsafe extern "C" {
    pub fn va_format(
        s: *mut u8_,
        format: *const ::std::os::raw::c_char,
        args: *mut va_list,
    ) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format(s: *mut u8_, format: *const ::std::os::raw::c_char, ...) -> *mut u8_;
}
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn va_fformat(f: *mut FILE, fmt: *mut ::std::os::raw::c_char, va: *mut va_list) -> word;
}
unsafe extern "C" {
    pub fn fformat(f: *mut FILE, fmt: *mut ::std::os::raw::c_char, ...) -> word;
}
unsafe extern "C" {
    pub fn fdformat(fd: ::std::os::raw::c_int, fmt: *mut ::std::os::raw::c_char, ...) -> word;
}
unsafe extern "C" {
    pub fn format_vec32(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_vec_uword(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_ascii_bytes(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_hex_bytes(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_hex_bytes_no_wrap(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_white_space(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_f64(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_time_interval(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_duration(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_address_family(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_network_address(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_network_protocol(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_network_port(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_sockaddr(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_timeval(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_time_float(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_signal(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_ucontext_pc(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _unformat_input_t {
    pub buffer: *mut u8_,
    pub index: uword,
    pub buffer_marks: *mut uword,
    pub fill_buffer:
        ::std::option::Option<unsafe extern "C" fn(i: *mut _unformat_input_t) -> uword>,
    pub free: ::std::option::Option<unsafe extern "C" fn(i: *mut _unformat_input_t)>,
    pub fill_buffer_arg: *mut ::std::os::raw::c_void,
}
impl Default for _unformat_input_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type unformat_input_t = _unformat_input_t;
unsafe extern "C" {
    pub fn unformat_skip_white_space(input: *mut unformat_input_t) -> uword;
}
pub type unformat_function_t = ::std::option::Option<
    unsafe extern "C" fn(input: *mut unformat_input_t, args: *mut va_list) -> uword,
>;
unsafe extern "C" {
    pub fn unformat(i: *mut unformat_input_t, fmt: *const ::std::os::raw::c_char, ...) -> uword;
}
unsafe extern "C" {
    pub fn unformat_user(input: *mut unformat_input_t, func: unformat_function_t, ...) -> uword;
}
unsafe extern "C" {
    pub fn va_unformat(
        i: *mut unformat_input_t,
        fmt: *const ::std::os::raw::c_char,
        args: *mut va_list,
    ) -> uword;
}
unsafe extern "C" {
    pub fn unformat_init_command_line(
        input: *mut unformat_input_t,
        argv: *mut *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn unformat_init_string(
        input: *mut unformat_input_t,
        string: *const ::std::os::raw::c_char,
        string_len: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn unformat_init_vector(input: *mut unformat_input_t, vector_string: *mut u8_);
}
unsafe extern "C" {
    pub fn unformat_u8(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn unformat_u16(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn format_unformat_error(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_unformat_input(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn unformat_input(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn unformat_line(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn unformat_line_input(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn unformat_token(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn unformat_hex_string(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn unformat_eof(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn unformat_memory_size(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn unformat_c_string_array(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn unformat_single_quoted_string(input: *mut unformat_input_t, args: *mut va_list)
    -> uword;
}
unsafe extern "C" {
    pub fn unformat_double_quoted_string(input: *mut unformat_input_t, args: *mut va_list)
    -> uword;
}
unsafe extern "C" {
    pub fn format_base10(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_memory_size(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn unformat_log2_page_size(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn format_log2_page_size(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_c_identifier(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_hexdump(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_hexdump_u16(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_hexdump_u32(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_hexdump_u64(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_uword_bitmap(s: *mut u8_, va: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn unformat_init_clib_file(
        input: *mut unformat_input_t,
        file_descriptor: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn unformat_init_file(
        input: *mut unformat_input_t,
        fmt: *mut ::std::os::raw::c_char,
        ...
    ) -> uword;
}
unsafe extern "C" {
    pub fn unformat_init_unix_env(
        input: *mut unformat_input_t,
        var: *mut ::std::os::raw::c_char,
    ) -> uword;
}
unsafe extern "C" {
    pub fn unformat_unix_gid(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn unformat_data_size(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn test_format_main(input: *mut unformat_input_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn test_unformat_main(input: *mut unformat_input_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn test_vec_main(input: *mut unformat_input_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn format_c_string(
        s: *mut u8_,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
pub const vnet_error_t_VNET_ERR_UNSPECIFIED: vnet_error_t = -1;
pub const vnet_error_t_VNET_ERR_INVALID_SW_IF_INDEX: vnet_error_t = -2;
pub const vnet_error_t_VNET_ERR_NO_SUCH_FIB: vnet_error_t = -3;
pub const vnet_error_t_VNET_ERR_NO_SUCH_INNER_FIB: vnet_error_t = -4;
pub const vnet_error_t_VNET_ERR_NO_SUCH_LABEL: vnet_error_t = -5;
pub const vnet_error_t_VNET_ERR_NO_SUCH_ENTRY: vnet_error_t = -6;
pub const vnet_error_t_VNET_ERR_INVALID_VALUE: vnet_error_t = -7;
pub const vnet_error_t_VNET_ERR_INVALID_VALUE_2: vnet_error_t = -8;
pub const vnet_error_t_VNET_ERR_UNIMPLEMENTED: vnet_error_t = -9;
pub const vnet_error_t_VNET_ERR_INVALID_SW_IF_INDEX_2: vnet_error_t = -10;
pub const vnet_error_t_VNET_ERR_SYSCALL_ERROR_1: vnet_error_t = -11;
pub const vnet_error_t_VNET_ERR_SYSCALL_ERROR_2: vnet_error_t = -12;
pub const vnet_error_t_VNET_ERR_SYSCALL_ERROR_3: vnet_error_t = -13;
pub const vnet_error_t_VNET_ERR_SYSCALL_ERROR_4: vnet_error_t = -14;
pub const vnet_error_t_VNET_ERR_SYSCALL_ERROR_5: vnet_error_t = -15;
pub const vnet_error_t_VNET_ERR_SYSCALL_ERROR_6: vnet_error_t = -16;
pub const vnet_error_t_VNET_ERR_SYSCALL_ERROR_7: vnet_error_t = -17;
pub const vnet_error_t_VNET_ERR_SYSCALL_ERROR_8: vnet_error_t = -18;
pub const vnet_error_t_VNET_ERR_SYSCALL_ERROR_9: vnet_error_t = -19;
pub const vnet_error_t_VNET_ERR_SYSCALL_ERROR_10: vnet_error_t = -20;
pub const vnet_error_t_VNET_ERR_FEATURE_DISABLED: vnet_error_t = -30;
pub const vnet_error_t_VNET_ERR_INVALID_REGISTRATION: vnet_error_t = -31;
pub const vnet_error_t_VNET_ERR_NEXT_HOP_NOT_IN_FIB: vnet_error_t = -50;
pub const vnet_error_t_VNET_ERR_UNKNOWN_DESTINATION: vnet_error_t = -51;
pub const vnet_error_t_VNET_ERR_NO_PATHS_IN_ROUTE: vnet_error_t = -52;
pub const vnet_error_t_VNET_ERR_NEXT_HOP_NOT_FOUND_MP: vnet_error_t = -53;
pub const vnet_error_t_VNET_ERR_NO_MATCHING_INTERFACE: vnet_error_t = -54;
pub const vnet_error_t_VNET_ERR_INVALID_VLAN: vnet_error_t = -55;
pub const vnet_error_t_VNET_ERR_VLAN_ALREADY_EXISTS: vnet_error_t = -56;
pub const vnet_error_t_VNET_ERR_INVALID_SRC_ADDRESS: vnet_error_t = -57;
pub const vnet_error_t_VNET_ERR_INVALID_DST_ADDRESS: vnet_error_t = -58;
pub const vnet_error_t_VNET_ERR_ADDRESS_LENGTH_MISMATCH: vnet_error_t = -59;
pub const vnet_error_t_VNET_ERR_ADDRESS_NOT_FOUND_FOR_INTERFACE: vnet_error_t = -60;
pub const vnet_error_t_VNET_ERR_ADDRESS_NOT_DELETABLE: vnet_error_t = -61;
pub const vnet_error_t_VNET_ERR_IP6_NOT_ENABLED: vnet_error_t = -62;
pub const vnet_error_t_VNET_ERR_NO_SUCH_NODE: vnet_error_t = -63;
pub const vnet_error_t_VNET_ERR_NO_SUCH_NODE2: vnet_error_t = -64;
pub const vnet_error_t_VNET_ERR_NO_SUCH_TABLE: vnet_error_t = -65;
pub const vnet_error_t_VNET_ERR_NO_SUCH_TABLE2: vnet_error_t = -66;
pub const vnet_error_t_VNET_ERR_NO_SUCH_TABLE3: vnet_error_t = -67;
pub const vnet_error_t_VNET_ERR_SUBIF_ALREADY_EXISTS: vnet_error_t = -68;
pub const vnet_error_t_VNET_ERR_SUBIF_CREATE_FAILED: vnet_error_t = -69;
pub const vnet_error_t_VNET_ERR_INVALID_MEMORY_SIZE: vnet_error_t = -70;
pub const vnet_error_t_VNET_ERR_INVALID_INTERFACE: vnet_error_t = -71;
pub const vnet_error_t_VNET_ERR_INVALID_VLAN_TAG_COUNT: vnet_error_t = -72;
pub const vnet_error_t_VNET_ERR_INVALID_ARGUMENT: vnet_error_t = -73;
pub const vnet_error_t_VNET_ERR_UNEXPECTED_INTF_STATE: vnet_error_t = -74;
pub const vnet_error_t_VNET_ERR_TUNNEL_EXIST: vnet_error_t = -75;
pub const vnet_error_t_VNET_ERR_INVALID_DECAP_NEXT: vnet_error_t = -76;
pub const vnet_error_t_VNET_ERR_RESPONSE_NOT_READY: vnet_error_t = -77;
pub const vnet_error_t_VNET_ERR_NOT_CONNECTED: vnet_error_t = -78;
pub const vnet_error_t_VNET_ERR_IF_ALREADY_EXISTS: vnet_error_t = -79;
pub const vnet_error_t_VNET_ERR_BOND_SLAVE_NOT_ALLOWED: vnet_error_t = -80;
pub const vnet_error_t_VNET_ERR_VALUE_EXIST: vnet_error_t = -81;
pub const vnet_error_t_VNET_ERR_SAME_SRC_DST: vnet_error_t = -82;
pub const vnet_error_t_VNET_ERR_IP6_MULTICAST_ADDRESS_NOT_PRESENT: vnet_error_t = -83;
pub const vnet_error_t_VNET_ERR_SR_POLICY_NAME_NOT_PRESENT: vnet_error_t = -84;
pub const vnet_error_t_VNET_ERR_NOT_RUNNING_AS_ROOT: vnet_error_t = -85;
pub const vnet_error_t_VNET_ERR_ALREADY_CONNECTED: vnet_error_t = -86;
pub const vnet_error_t_VNET_ERR_UNSUPPORTED_JNI_VERSION: vnet_error_t = -87;
pub const vnet_error_t_VNET_ERR_IP_PREFIX_INVALID: vnet_error_t = -88;
pub const vnet_error_t_VNET_ERR_INVALID_WORKER: vnet_error_t = -89;
pub const vnet_error_t_VNET_ERR_LISP_DISABLED: vnet_error_t = -90;
pub const vnet_error_t_VNET_ERR_CLASSIFY_TABLE_NOT_FOUND: vnet_error_t = -91;
pub const vnet_error_t_VNET_ERR_INVALID_EID_TYPE: vnet_error_t = -92;
pub const vnet_error_t_VNET_ERR_CANNOT_CREATE_PCAP_FILE: vnet_error_t = -93;
pub const vnet_error_t_VNET_ERR_INCORRECT_ADJACENCY_TYPE: vnet_error_t = -94;
pub const vnet_error_t_VNET_ERR_EXCEEDED_NUMBER_OF_RANGES_CAPACITY: vnet_error_t = -95;
pub const vnet_error_t_VNET_ERR_EXCEEDED_NUMBER_OF_PORTS_CAPACITY: vnet_error_t = -96;
pub const vnet_error_t_VNET_ERR_INVALID_ADDRESS_FAMILY: vnet_error_t = -97;
pub const vnet_error_t_VNET_ERR_INVALID_SUB_SW_IF_INDEX: vnet_error_t = -98;
pub const vnet_error_t_VNET_ERR_TABLE_TOO_BIG: vnet_error_t = -99;
pub const vnet_error_t_VNET_ERR_CANNOT_ENABLE_DISABLE_FEATURE: vnet_error_t = -100;
pub const vnet_error_t_VNET_ERR_BFD_EEXIST: vnet_error_t = -101;
pub const vnet_error_t_VNET_ERR_BFD_ENOENT: vnet_error_t = -102;
pub const vnet_error_t_VNET_ERR_BFD_EINUSE: vnet_error_t = -103;
pub const vnet_error_t_VNET_ERR_BFD_NOTSUPP: vnet_error_t = -104;
pub const vnet_error_t_VNET_ERR_ADDRESS_IN_USE: vnet_error_t = -105;
pub const vnet_error_t_VNET_ERR_ADDRESS_NOT_IN_USE: vnet_error_t = -106;
pub const vnet_error_t_VNET_ERR_QUEUE_FULL: vnet_error_t = -107;
pub const vnet_error_t_VNET_ERR_APP_UNSUPPORTED_CFG: vnet_error_t = -108;
pub const vnet_error_t_VNET_ERR_URI_FIFO_CREATE_FAILED: vnet_error_t = -109;
pub const vnet_error_t_VNET_ERR_LISP_RLOC_LOCAL: vnet_error_t = -110;
pub const vnet_error_t_VNET_ERR_BFD_EAGAIN: vnet_error_t = -111;
pub const vnet_error_t_VNET_ERR_INVALID_GPE_MODE: vnet_error_t = -112;
pub const vnet_error_t_VNET_ERR_LISP_GPE_ENTRIES_PRESENT: vnet_error_t = -113;
pub const vnet_error_t_VNET_ERR_ADDRESS_FOUND_FOR_INTERFACE: vnet_error_t = -114;
pub const vnet_error_t_VNET_ERR_SESSION_CONNECT: vnet_error_t = -115;
pub const vnet_error_t_VNET_ERR_ENTRY_ALREADY_EXISTS: vnet_error_t = -116;
pub const vnet_error_t_VNET_ERR_SVM_SEGMENT_CREATE_FAIL: vnet_error_t = -117;
pub const vnet_error_t_VNET_ERR_APPLICATION_NOT_ATTACHED: vnet_error_t = -118;
pub const vnet_error_t_VNET_ERR_BD_ALREADY_EXISTS: vnet_error_t = -119;
pub const vnet_error_t_VNET_ERR_BD_IN_USE: vnet_error_t = -120;
pub const vnet_error_t_VNET_ERR_BD_NOT_MODIFIABLE: vnet_error_t = -121;
pub const vnet_error_t_VNET_ERR_BD_ID_EXCEED_MAX: vnet_error_t = -122;
pub const vnet_error_t_VNET_ERR_SUBIF_DOESNT_EXIST: vnet_error_t = -123;
pub const vnet_error_t_VNET_ERR_L2_MACS_EVENT_CLINET_PRESENT: vnet_error_t = -124;
pub const vnet_error_t_VNET_ERR_INVALID_QUEUE: vnet_error_t = -125;
pub const vnet_error_t_VNET_ERR_UNSUPPORTED: vnet_error_t = -126;
pub const vnet_error_t_VNET_ERR_DUPLICATE_IF_ADDRESS: vnet_error_t = -127;
pub const vnet_error_t_VNET_ERR_APP_INVALID_NS: vnet_error_t = -128;
pub const vnet_error_t_VNET_ERR_APP_WRONG_NS_SECRET: vnet_error_t = -129;
pub const vnet_error_t_VNET_ERR_APP_CONNECT_SCOPE: vnet_error_t = -130;
pub const vnet_error_t_VNET_ERR_APP_ALREADY_ATTACHED: vnet_error_t = -131;
pub const vnet_error_t_VNET_ERR_SESSION_REDIRECT: vnet_error_t = -132;
pub const vnet_error_t_VNET_ERR_ILLEGAL_NAME: vnet_error_t = -133;
pub const vnet_error_t_VNET_ERR_NO_NAME_SERVERS: vnet_error_t = -134;
pub const vnet_error_t_VNET_ERR_NAME_SERVER_NOT_FOUND: vnet_error_t = -135;
pub const vnet_error_t_VNET_ERR_NAME_RESOLUTION_NOT_ENABLED: vnet_error_t = -136;
pub const vnet_error_t_VNET_ERR_NAME_SERVER_FORMAT_ERROR: vnet_error_t = -137;
pub const vnet_error_t_VNET_ERR_NAME_SERVER_NO_SUCH_NAME: vnet_error_t = -138;
pub const vnet_error_t_VNET_ERR_NAME_SERVER_NO_ADDRESSES: vnet_error_t = -139;
pub const vnet_error_t_VNET_ERR_NAME_SERVER_NEXT_SERVER: vnet_error_t = -140;
pub const vnet_error_t_VNET_ERR_APP_CONNECT_FILTERED: vnet_error_t = -141;
pub const vnet_error_t_VNET_ERR_ACL_IN_USE_INBOUND: vnet_error_t = -142;
pub const vnet_error_t_VNET_ERR_ACL_IN_USE_OUTBOUND: vnet_error_t = -143;
pub const vnet_error_t_VNET_ERR_INIT_FAILED: vnet_error_t = -144;
pub const vnet_error_t_VNET_ERR_NETLINK_ERROR: vnet_error_t = -145;
pub const vnet_error_t_VNET_ERR_BIER_BSL_UNSUP: vnet_error_t = -146;
pub const vnet_error_t_VNET_ERR_INSTANCE_IN_USE: vnet_error_t = -147;
pub const vnet_error_t_VNET_ERR_INVALID_SESSION_ID: vnet_error_t = -148;
pub const vnet_error_t_VNET_ERR_ACL_IN_USE_BY_LOOKUP_CONTEXT: vnet_error_t = -149;
pub const vnet_error_t_VNET_ERR_INVALID_VALUE_3: vnet_error_t = -150;
pub const vnet_error_t_VNET_ERR_NON_ETHERNET: vnet_error_t = -151;
pub const vnet_error_t_VNET_ERR_BD_ALREADY_HAS_BVI: vnet_error_t = -152;
pub const vnet_error_t_VNET_ERR_INVALID_PROTOCOL: vnet_error_t = -153;
pub const vnet_error_t_VNET_ERR_INVALID_ALGORITHM: vnet_error_t = -154;
pub const vnet_error_t_VNET_ERR_RSRC_IN_USE: vnet_error_t = -155;
pub const vnet_error_t_VNET_ERR_KEY_LENGTH: vnet_error_t = -156;
pub const vnet_error_t_VNET_ERR_FIB_PATH_UNSUPPORTED_NH_PROTO: vnet_error_t = -157;
pub const vnet_error_t_VNET_ERR_API_ENDIAN_FAILED: vnet_error_t = -159;
pub const vnet_error_t_VNET_ERR_NO_CHANGE: vnet_error_t = -160;
pub const vnet_error_t_VNET_ERR_MISSING_CERT_KEY: vnet_error_t = -161;
pub const vnet_error_t_VNET_ERR_LIMIT_EXCEEDED: vnet_error_t = -162;
pub const vnet_error_t_VNET_ERR_IKE_NO_PORT: vnet_error_t = -163;
pub const vnet_error_t_VNET_ERR_UDP_PORT_TAKEN: vnet_error_t = -164;
pub const vnet_error_t_VNET_ERR_EAGAIN: vnet_error_t = -165;
pub const vnet_error_t_VNET_ERR_INVALID_VALUE_4: vnet_error_t = -166;
pub const vnet_error_t_VNET_ERR_BUSY: vnet_error_t = -167;
pub const vnet_error_t_VNET_ERR_BUG: vnet_error_t = -168;
pub const vnet_error_t_VNET_ERR_FEATURE_ALREADY_DISABLED: vnet_error_t = -169;
pub const vnet_error_t_VNET_ERR_FEATURE_ALREADY_ENABLED: vnet_error_t = -170;
pub const vnet_error_t_VNET_ERR_INVALID_PREFIX_LENGTH: vnet_error_t = -171;
pub const vnet_error_t_VNET_N_ERROR: vnet_error_t = -170;
pub type vnet_error_t = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn vnet_error(
        code: vnet_error_t,
        fmt: *mut ::std::os::raw::c_char,
        ...
    ) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn format_vnet_api_errno(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
pub const vlib_rx_or_tx_t_VLIB_RX: vlib_rx_or_tx_t = 0;
pub const vlib_rx_or_tx_t_VLIB_TX: vlib_rx_or_tx_t = 1;
pub const vlib_rx_or_tx_t_VLIB_N_RX_TX: vlib_rx_or_tx_t = 2;
pub type vlib_rx_or_tx_t = ::std::os::raw::c_uint;
pub use self::vlib_rx_or_tx_t as vlib_dir_t;
pub const vlib_read_or_write_t_VLIB_READ: vlib_read_or_write_t = 0;
pub const vlib_read_or_write_t_VLIB_WRITE: vlib_read_or_write_t = 1;
pub type vlib_read_or_write_t = ::std::os::raw::c_uint;
pub const vlib_up_or_down_t_VLIB_DOWN: vlib_up_or_down_t = 0;
pub const vlib_up_or_down_t_VLIB_UP: vlib_up_or_down_t = 1;
pub type vlib_up_or_down_t = ::std::os::raw::c_uint;
pub const vlib_enable_or_disable_t_VLIB_DISABLE: vlib_enable_or_disable_t = 0;
pub const vlib_enable_or_disable_t_VLIB_ENABLE: vlib_enable_or_disable_t = 1;
pub type vlib_enable_or_disable_t = ::std::os::raw::c_uint;
pub type vlib_log_class_t = u32_;
pub type clib_bitmap_t = uword;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct clib_pmalloc_chunk_t {
    pub start: u32_,
    pub prev: u32_,
    pub next: u32_,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl clib_pmalloc_chunk_t {
    #[inline]
    pub fn size(&self) -> u32_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn size_raw(this: *const Self) -> u32_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_size_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn used(&self) -> u32_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_used(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn used_raw(this: *const Self) -> u32_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_used_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(size: u32_, used: u32_) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let size: u32 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let used: u32 = unsafe { ::std::mem::transmute(used) };
            used as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clib_pmalloc_page_t {
    pub index: u32_,
    pub arena_index: u32_,
    pub chunks: *mut clib_pmalloc_chunk_t,
    pub first_chunk_index: u32_,
    pub n_free_chunks: u32_,
    pub n_free_blocks: u32_,
}
impl Default for clib_pmalloc_page_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clib_pmalloc_arena_t {
    pub index: u32_,
    pub flags: u32_,
    pub fd: ::std::os::raw::c_int,
    pub numa_node: u32_,
    pub first_page_index: u32_,
    pub log2_subpage_sz: u32_,
    pub subpages_per_page: u32_,
    pub n_pages: u32_,
    pub name: *mut u8_,
    pub page_indices: *mut u32_,
}
impl Default for clib_pmalloc_arena_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clib_pmalloc_main_t {
    pub flags: u32_,
    pub base: *mut u8_,
    pub def_log2_page_sz: clib_mem_page_sz_t,
    pub max_pages: u32_,
    pub pages: *mut clib_pmalloc_page_t,
    pub chunk_index_by_va: *mut uword,
    pub arenas: *mut clib_pmalloc_arena_t,
    pub default_arena_for_numa_node: *mut u32_,
    pub lookup_table: *mut uword,
    pub lookup_log2_page_sz: u32_,
    pub error: *mut clib_error_t,
}
impl Default for clib_pmalloc_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_physmem_map_t {
    pub index: ::std::os::raw::c_int,
    pub fd: ::std::os::raw::c_int,
    pub base: *mut ::std::os::raw::c_void,
    pub n_pages: u32_,
    pub page_table: *mut uword,
    pub log2_page_size: u32_,
    pub numa_node: u32_,
}
impl Default for vlib_physmem_map_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_physmem_main_t {
    pub flags: u32_,
    pub base_addr: uword,
    pub max_size: uword,
    pub maps: *mut vlib_physmem_map_t,
    pub pmalloc_main: *mut clib_pmalloc_main_t,
}
impl Default for vlib_physmem_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct clib_longjmp_t {
    pub regs: [uword; 8usize],
}
pub type vlib_error_t = u16_;
pub const vl_counter_severity_e_VL_COUNTER_SEVERITY_ERROR: vl_counter_severity_e = 0;
pub const vl_counter_severity_e_VL_COUNTER_SEVERITY_WARN: vl_counter_severity_e = 1;
pub const vl_counter_severity_e_VL_COUNTER_SEVERITY_INFO: vl_counter_severity_e = 2;
pub type vl_counter_severity_e = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_error_desc_t {
    pub name: *mut ::std::os::raw::c_char,
    pub desc: *mut ::std::os::raw::c_char,
    pub severity: vl_counter_severity_e,
    pub stats_entry_index: u32_,
}
impl Default for vlib_error_desc_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_error_main_t {
    pub counters: *mut u64_,
    pub counters_last_clear: *mut u64_,
    pub counters_heap: *mut vlib_error_desc_t,
    pub stats_err_entry_index: u32_,
}
impl Default for vlib_error_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VLIB_BUFFER_IS_TRACED: _bindgen_ty_30 = 1;
pub const VLIB_BUFFER_NEXT_PRESENT: _bindgen_ty_30 = 2;
pub const VLIB_BUFFER_TOTAL_LENGTH_VALID: _bindgen_ty_30 = 4;
pub const VLIB_BUFFER_EXT_HDR_VALID: _bindgen_ty_30 = 8;
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
pub const VLIB_BUFFER_LOG2_IS_TRACED: _bindgen_ty_31 = 0;
pub const VLIB_BUFFER_LOG2_NEXT_PRESENT: _bindgen_ty_31 = 1;
pub const VLIB_BUFFER_LOG2_TOTAL_LENGTH_VALID: _bindgen_ty_31 = 2;
pub const VLIB_BUFFER_LOG2_EXT_HDR_VALID: _bindgen_ty_31 = 3;
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(64))]
pub struct vlib_buffer_template_t {
    pub align_mark: __IncompleteArrayField<u8_>,
    pub current_data: i16_,
    pub current_length: u16_,
    pub flags: u32_,
    pub flow_id: u32_,
    pub ref_count: u8_,
    pub buffer_pool_index: u8_,
    pub error: vlib_error_t,
    pub next_buffer: u32_,
    pub __bindgen_anon_1: vlib_buffer_template_t__bindgen_ty_1,
    pub opaque: [u32_; 10usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vlib_buffer_template_t__bindgen_ty_1 {
    pub current_config_index: u32_,
    pub punt_reason: u32_,
}
impl Default for vlib_buffer_template_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vlib_buffer_template_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct vlib_buffer_t__bindgen_ty_1<FAM: ?Sized = [u8_; 0]> {
    pub __bindgen_anon_1: vlib_buffer_t__bindgen_ty_1__bindgen_ty_1,
    pub second_half: __IncompleteArrayField<u8_>,
    pub trace_handle: u32_,
    pub total_length_not_including_first_buffer: u32_,
    pub opaque2: [u32_; 14usize],
    pub headroom: __IncompleteArrayField<u8_>,
    pub pre_data: [u8_; 128usize],
    pub data: FAM,
}
#[repr(C)]
#[repr(align(64))]
pub struct vlib_buffer_t__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1:
        __BindgenUnionField<vlib_buffer_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
    pub template: __BindgenUnionField<vlib_buffer_template_t>,
    pub bindgen_union_field: [u8; 64usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vlib_buffer_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub current_data: i16_,
    pub current_length: u16_,
    pub flags: u32_,
    pub flow_id: u32_,
    pub ref_count: u8_,
    pub buffer_pool_index: u8_,
    pub error: vlib_error_t,
    pub next_buffer: u32_,
    pub __bindgen_anon_1: vlib_buffer_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub opaque: [u32_; 10usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vlib_buffer_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub current_config_index: u32_,
    pub punt_reason: u32_,
}
impl Default for vlib_buffer_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vlib_buffer_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vlib_buffer_t__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl vlib_buffer_t__bindgen_ty_1<[u8_]> {}
impl vlib_buffer_t__bindgen_ty_1<[u8_; 0]> {}
impl Default for vlib_buffer_t__bindgen_ty_1<[u8_; 0]> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct vlib_buffer_pool_thread_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub cached_buffers: [u32_; 512usize],
    pub n_cached: u32_,
}
impl Default for vlib_buffer_pool_thread_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct vlib_buffer_pool_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub start: uword,
    pub size: uword,
    pub log2_page_size: u8_,
    pub index: u8_,
    pub numa_node: u8_,
    pub physmem_map_index: u32_,
    pub data_size: u32_,
    pub alloc_size: u32_,
    pub n_buffers: u32_,
    pub n_avail: u32_,
    pub buffers: *mut u32_,
    pub name: *mut u8_,
    pub lock: clib_spinlock_t,
    pub threads: *mut vlib_buffer_pool_thread_t,
    pub __bindgen_padding_0: [u64; 7usize],
    pub buffer_template: vlib_buffer_template_t,
}
impl Default for vlib_buffer_pool_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vlib_buffer_alloc_free_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        vm: *mut vlib_main_t,
        buffer_pool_index: u8_,
        buffers: *mut u32_,
        n_buffers: u32_,
    ) -> u32_,
>;
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct vlib_buffer_main_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub buffer_mem_start: uword,
    pub buffer_mem_size: uword,
    pub buffer_pools: *mut vlib_buffer_pool_t,
    pub alloc_callback_fn: vlib_buffer_alloc_free_callback_t,
    pub free_callback_fn: vlib_buffer_alloc_free_callback_t,
    pub default_buffer_pool_index_for_numa: [u8_; 32usize],
    pub default_buffers_per_numa: u32_,
    pub buffers_per_numa: [u32_; 32usize],
    pub ext_hdr_size: u16_,
    pub default_data_size: u32_,
    pub log2_page_size: clib_mem_page_sz_t,
    pub buffer_known_hash: *mut uword,
    pub buffer_known_hash_lockp: clib_spinlock_t,
    pub log_default: vlib_log_class_t,
}
impl Default for vlib_buffer_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn vlib_buffer_main_init(vm: *mut vlib_main_t) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn format_vlib_buffer_pool_all(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn vlib_buffer_set_alloc_free_callback(
        vm: *mut vlib_main_t,
        alloc_callback_fn: vlib_buffer_alloc_free_callback_t,
        free_callback_fn: vlib_buffer_alloc_free_callback_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __vlib_buffer_external_hdr_size: u16_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_cli_parse_position_t {
    pub min_char: u32_,
    pub bitmaps: *mut *mut uword,
}
impl Default for vlib_cli_parse_position_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_cli_sub_command_t {
    pub name: *mut u8_,
    pub index: u32_,
}
impl Default for vlib_cli_sub_command_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_cli_sub_rule_t {
    pub name: *mut u8_,
    pub rule_index: u32_,
    pub command_index: u32_,
}
impl Default for vlib_cli_sub_rule_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_cli_parse_rule_t {
    pub name: *mut ::std::os::raw::c_char,
    pub short_help: *mut ::std::os::raw::c_char,
    pub long_help: *mut ::std::os::raw::c_char,
    pub data_size: uword,
    pub unformat_function: unformat_function_t,
    pub unformat_function_arg: [uword; 2usize],
}
impl Default for vlib_cli_parse_rule_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vlib_cli_command_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        vm: *mut vlib_main_t,
        input: *mut unformat_input_t,
        cmd: *mut vlib_cli_command_t,
    ) -> *mut clib_error_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_cli_command_t {
    pub path: *mut ::std::os::raw::c_char,
    pub short_help: *mut ::std::os::raw::c_char,
    pub long_help: *mut ::std::os::raw::c_char,
    pub function: vlib_cli_command_function_t,
    pub function_arg: uword,
    pub is_mp_safe: uword,
    pub sub_commands: *mut vlib_cli_sub_command_t,
    pub sub_command_index_by_name: *mut uword,
    pub sub_command_positions: *mut vlib_cli_parse_position_t,
    pub sub_rule_index_by_name: *mut uword,
    pub sub_rules: *mut vlib_cli_sub_rule_t,
    pub next_cli_command: *mut vlib_cli_command_t,
    pub hit_counter: u32_,
}
impl Default for vlib_cli_command_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vlib_cli_output_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg: uword, buffer: *mut u8_, buffer_bytes: uword)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_cli_main_t {
    pub commands: *mut vlib_cli_command_t,
    pub command_index_by_path: *mut uword,
    pub cli_command_registrations: *mut vlib_cli_command_t,
    pub sort_vector: *mut u32_,
    pub perf_counter_cbs: *mut ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vlib_cli_main_t,
            id: u32_,
            before_or_after: ::std::os::raw::c_int,
        ),
    >,
    pub perf_counter_cbs_tmp: *mut ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut vlib_cli_main_t,
            id: u32_,
            before_or_after: ::std::os::raw::c_int,
        ),
    >,
    pub log: vlib_log_class_t,
}
impl Default for vlib_cli_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn vlib_cli_output(vm: *mut vlib_main_t, fmt: *mut ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn vlib_cli_input(
        vm: *mut vlib_main_t,
        input: *mut unformat_input_t,
        function: vlib_cli_output_function_t,
        function_arg: uword,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vlib_cli_register(vm: *mut vlib_main_t, c: *mut vlib_cli_command_t)
    -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn vlib_cli_register_parse_rule(
        vm: *mut vlib_main_t,
        c: *mut vlib_cli_parse_rule_t,
    ) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn unformat_vlib_cli_line(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn unformat_vlib_cli_sub_input(i: *mut unformat_input_t, args: *mut va_list) -> uword;
}
unsafe extern "C" {
    pub fn vlib_cli_get_possible_completions(input_str: *mut u8_) -> *mut *mut u8_;
}
pub type counter_t = u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vlib_counter_t {
    pub packets: counter_t,
    pub bytes: counter_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_simple_counter_main_t {
    pub counters: *mut *mut counter_t,
    pub name: *mut ::std::os::raw::c_char,
    pub stat_segment_name: *mut ::std::os::raw::c_char,
    pub stats_entry_index: u32_,
}
impl Default for vlib_simple_counter_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_combined_counter_main_t {
    pub counters: *mut *mut vlib_counter_t,
    pub name: *mut ::std::os::raw::c_char,
    pub stat_segment_name: *mut ::std::os::raw::c_char,
    pub stats_entry_index: u32_,
}
impl Default for vlib_combined_counter_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vlib_init_function_t =
    ::std::option::Option<unsafe extern "C" fn(vm: *mut vlib_main_t) -> *mut clib_error_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vlib_init_function_list_elt {
    pub next_init_function: *mut _vlib_init_function_list_elt,
    pub f: vlib_init_function_t,
    pub name: *mut ::std::os::raw::c_char,
    pub runs_before: *mut *mut ::std::os::raw::c_char,
    pub runs_after: *mut *mut ::std::os::raw::c_char,
    pub init_order: *mut *mut ::std::os::raw::c_char,
}
impl Default for _vlib_init_function_list_elt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _vlib_init_function_list_elt_t = _vlib_init_function_list_elt;
pub type vlib_config_function_t = ::std::option::Option<
    unsafe extern "C" fn(vm: *mut vlib_main_t, input: *mut unformat_input_t) -> *mut clib_error_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_config_function_runtime_t {
    pub function: vlib_config_function_t,
    pub input: unformat_input_t,
    pub next_registration: *mut vlib_config_function_runtime_t,
    pub is_early: u8_,
    pub name: [::std::os::raw::c_char; 32usize],
}
impl Default for vlib_config_function_runtime_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn vlib_call_all_init_functions(vm: *mut vlib_main_t) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn vlib_call_all_config_functions(
        vm: *mut vlib_main_t,
        input: *mut unformat_input_t,
        is_early: ::std::os::raw::c_int,
    ) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn vlib_call_all_main_loop_enter_functions(vm: *mut vlib_main_t) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn vlib_call_all_main_loop_exit_functions(vm: *mut vlib_main_t) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn vlib_call_init_exit_functions(
        vm: *mut vlib_main_t,
        headp: *mut *mut _vlib_init_function_list_elt_t,
        call_once: ::std::os::raw::c_int,
        is_global: ::std::os::raw::c_int,
    ) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn vlib_call_init_exit_functions_no_sort(
        vm: *mut vlib_main_t,
        headp: *mut *mut _vlib_init_function_list_elt_t,
        call_once: ::std::os::raw::c_int,
        is_global: ::std::os::raw::c_int,
    ) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn vlib_sort_init_exit_functions(
        arg1: *mut *mut _vlib_init_function_list_elt_t,
    ) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn vlib_node_cli_reference();
}
unsafe extern "C" {
    pub fn vlib_trace_cli_reference();
}
pub const clib_march_variant_type_t_CLIB_MARCH_VARIANT_TYPE: clib_march_variant_type_t = 0;
pub const clib_march_variant_type_t_CLIB_MARCH_VARIANT_TYPE_scalar: clib_march_variant_type_t = 1;
pub const clib_march_variant_type_t_CLIB_MARCH_VARIANT_TYPE_hsw: clib_march_variant_type_t = 2;
pub const clib_march_variant_type_t_CLIB_MARCH_VARIANT_TYPE_trm: clib_march_variant_type_t = 3;
pub const clib_march_variant_type_t_CLIB_MARCH_VARIANT_TYPE_skx: clib_march_variant_type_t = 4;
pub const clib_march_variant_type_t_CLIB_MARCH_VARIANT_TYPE_icl: clib_march_variant_type_t = 5;
pub const clib_march_variant_type_t_CLIB_MARCH_VARIANT_TYPE_adl: clib_march_variant_type_t = 6;
pub const clib_march_variant_type_t_CLIB_MARCH_VARIANT_TYPE_spr: clib_march_variant_type_t = 7;
pub const clib_march_variant_type_t_CLIB_MARCH_VARIANT_TYPE_znver3: clib_march_variant_type_t = 8;
pub const clib_march_variant_type_t_CLIB_MARCH_VARIANT_TYPE_znver4: clib_march_variant_type_t = 9;
pub const clib_march_variant_type_t_CLIB_MARCH_TYPE_N_VARIANTS: clib_march_variant_type_t = 10;
pub type clib_march_variant_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default)]
pub struct vlib_trace_header_t<FAM: ?Sized = [u8_; 0]> {
    pub time: u64_,
    pub node_index: u32_,
    pub n_data: u32_,
    pub data: FAM,
}
impl vlib_trace_header_t<[u8_]> {}
impl vlib_trace_header_t<[u8_; 0]> {}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vlib_trace_node_t {
    pub count: u32_,
    pub limit: u32_,
}
pub type vlib_trace_buffer_callback_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut vlib_main_t, arg2: *mut vlib_trace_main_t),
>;
pub type vlib_add_trace_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut vlib_main_t,
        r: *mut vlib_node_runtime_t,
        b: *mut vlib_buffer_t,
        n_data_bytes: u32_,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type vlib_is_packet_traced_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        b: *mut vlib_buffer_t,
        classify_table_index: u32_,
        func: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type vlib_node_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        vm: *mut vlib_main_t,
        node: *mut vlib_node_runtime_t,
        frame: *mut vlib_frame_t,
    ) -> uword,
>;
pub const vlib_node_proto_hint_t_VLIB_NODE_PROTO_HINT_NONE: vlib_node_proto_hint_t = 0;
pub const vlib_node_proto_hint_t_VLIB_NODE_PROTO_HINT_ETHERNET: vlib_node_proto_hint_t = 1;
pub const vlib_node_proto_hint_t_VLIB_NODE_PROTO_HINT_IP4: vlib_node_proto_hint_t = 2;
pub const vlib_node_proto_hint_t_VLIB_NODE_PROTO_HINT_IP6: vlib_node_proto_hint_t = 3;
pub const vlib_node_proto_hint_t_VLIB_NODE_PROTO_HINT_TCP: vlib_node_proto_hint_t = 4;
pub const vlib_node_proto_hint_t_VLIB_NODE_PROTO_HINT_UDP: vlib_node_proto_hint_t = 5;
pub const vlib_node_proto_hint_t_VLIB_NODE_N_PROTO_HINTS: vlib_node_proto_hint_t = 6;
pub type vlib_node_proto_hint_t = ::std::os::raw::c_uint;
pub const vlib_node_type_t_VLIB_NODE_TYPE_INTERNAL: vlib_node_type_t = 0;
pub const vlib_node_type_t_VLIB_NODE_TYPE_INPUT: vlib_node_type_t = 1;
pub const vlib_node_type_t_VLIB_NODE_TYPE_PRE_INPUT: vlib_node_type_t = 2;
pub const vlib_node_type_t_VLIB_NODE_TYPE_PROCESS: vlib_node_type_t = 3;
pub const vlib_node_type_t_VLIB_N_NODE_TYPE: vlib_node_type_t = 4;
pub type vlib_node_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vlib_node_fn_registration {
    pub function: vlib_node_function_t,
    pub march_variant: clib_march_variant_type_t,
    pub next_registration: *mut _vlib_node_fn_registration,
}
impl Default for _vlib_node_fn_registration {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vlib_node_fn_registration_t = _vlib_node_fn_registration;
#[repr(C)]
#[derive(Debug)]
pub struct _vlib_node_registration<FAM: ?Sized = [*mut ::std::os::raw::c_char; 0]> {
    pub function: vlib_node_function_t,
    pub node_fn_registrations: *mut vlib_node_fn_registration_t,
    pub name: *mut ::std::os::raw::c_char,
    pub sibling_of: *mut ::std::os::raw::c_char,
    pub index: u32_,
    pub type_: vlib_node_type_t,
    pub error_strings: *mut *mut ::std::os::raw::c_char,
    pub error_counters: *mut vlib_error_desc_t,
    pub format_buffer: format_function_t,
    pub unformat_buffer: unformat_function_t,
    pub format_trace: format_function_t,
    pub unformat_trace: unformat_function_t,
    pub validate_frame: ::std::option::Option<
        unsafe extern "C" fn(
            vm: *mut vlib_main_t,
            arg1: *mut vlib_node_runtime_t,
            f: *mut vlib_frame_t,
        ) -> *mut u8_,
    >,
    pub runtime_data: *mut ::std::os::raw::c_void,
    pub process_log2_n_stack_bytes: u16_,
    pub runtime_data_bytes: u8_,
    pub state: u8_,
    pub flags: u16_,
    pub protocol_hint: u8_,
    pub vector_size: u8_,
    pub aux_size: u8_,
    pub scalar_size: u16_,
    pub n_errors: u16_,
    pub n_next_nodes: u16_,
    pub next_registration: *mut _vlib_node_registration,
    pub next_nodes: FAM,
}
impl _vlib_node_registration<[*mut ::std::os::raw::c_char]> {}
impl _vlib_node_registration<[*mut ::std::os::raw::c_char; 0]> {}
impl Default for _vlib_node_registration<[*mut ::std::os::raw::c_char; 0]> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vlib_node_registration_t = _vlib_node_registration;
unsafe extern "C" {
    pub fn unformat_vlib_node_variant(input: *mut unformat_input_t, args: *mut va_list) -> uword;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vlib_node_stats_t {
    pub calls: u64_,
    pub vectors: u64_,
    pub clocks: u64_,
    pub suspends: u64_,
    pub max_clock: u64_,
    pub max_clock_n: u64_,
}
pub const vlib_node_state_t_VLIB_NODE_STATE_POLLING: vlib_node_state_t = 0;
pub const vlib_node_state_t_VLIB_NODE_STATE_INTERRUPT: vlib_node_state_t = 1;
pub const vlib_node_state_t_VLIB_NODE_STATE_DISABLED: vlib_node_state_t = 2;
pub const vlib_node_state_t_VLIB_N_NODE_STATE: vlib_node_state_t = 3;
pub type vlib_node_state_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_node_t {
    pub function: vlib_node_function_t,
    pub name: *mut u8_,
    pub name_elog_string: u32_,
    pub stats_total: vlib_node_stats_t,
    pub stats_last_clear: vlib_node_stats_t,
    pub type_: vlib_node_type_t,
    pub index: u32_,
    pub runtime_index: u32_,
    pub runtime_data: *mut u8_,
    pub flags: u16_,
    pub state: u8_,
    pub runtime_data_bytes: u8_,
    pub protocol_hint: u8_,
    pub n_errors: u16_,
    pub frame_size: u16_,
    pub scalar_offset: u16_,
    pub vector_offset: u16_,
    pub magic_offset: u16_,
    pub aux_offset: u16_,
    pub frame_size_index: u16_,
    pub error_heap_handle: u32_,
    pub error_heap_index: u32_,
    pub error_counters: *mut vlib_error_desc_t,
    pub next_node_names: *mut *mut ::std::os::raw::c_char,
    pub next_nodes: *mut u32_,
    pub sibling_of: *mut ::std::os::raw::c_char,
    pub sibling_bitmap: *mut uword,
    pub n_vectors_by_next_node: *mut u64_,
    pub next_slot_by_node: *mut uword,
    pub prev_node_bitmap: *mut uword,
    pub owner_node_index: u32_,
    pub owner_next_index: u32_,
    pub format_buffer: format_function_t,
    pub unformat_buffer: unformat_function_t,
    pub format_trace: format_function_t,
    pub validate_frame: ::std::option::Option<
        unsafe extern "C" fn(
            vm: *mut vlib_main_t,
            arg1: *mut vlib_node_runtime_t,
            f: *mut vlib_frame_t,
        ) -> *mut u8_,
    >,
    pub state_string: *mut u8_,
    pub node_fn_registrations: *mut vlib_node_fn_registration_t,
}
impl Default for vlib_node_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct vlib_frame_t<FAM: ?Sized = [u8_; 0]> {
    pub frame_flags: u16_,
    pub flags: u16_,
    pub scalar_offset: u16_,
    pub vector_offset: u16_,
    pub aux_offset: u16_,
    pub n_vectors: u16_,
    pub frame_size_index: u16_,
    pub arguments: FAM,
}
impl vlib_frame_t<[u8_]> {}
impl vlib_frame_t<[u8_; 0]> {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_next_frame_t {
    pub frame: *mut vlib_frame_t,
    pub node_runtime_index: u32_,
    pub flags: u32_,
    pub vectors_since_last_overflow: u32_,
}
impl Default for vlib_next_frame_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_pending_frame_t {
    pub frame: *mut vlib_frame_t,
    pub node_runtime_index: u32_,
    pub next_frame_index: u32_,
}
impl Default for vlib_pending_frame_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct vlib_node_runtime_t<FAM: ?Sized = [u8_; 0]> {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub function: vlib_node_function_t,
    pub errors: *mut vlib_error_t,
    pub clocks_since_last_overflow: u32_,
    pub max_clock: u32_,
    pub max_clock_n: u32_,
    pub calls_since_last_overflow: u32_,
    pub vectors_since_last_overflow: u32_,
    pub next_frame_index: u32_,
    pub node_index: u32_,
    pub input_main_loops_per_call: u32_,
    pub main_loop_count_last_dispatch: u32_,
    pub main_loop_vector_stats: [u32_; 2usize],
    pub flags: u16_,
    pub state: u16_,
    pub n_next_nodes: u16_,
    pub cached_next_index: u16_,
    pub __bindgen_padding_0: [u8; 4usize],
    pub runtime_data_pad: __IncompleteArrayField<u8_>,
    pub runtime_data: FAM,
}
impl vlib_node_runtime_t<[u8_]> {}
impl vlib_node_runtime_t<[u8_; 0]> {}
impl Default for vlib_node_runtime_t<[u8_; 0]> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_frame_size_t {
    pub n_alloc_frames: u32_,
    pub frame_size: u16_,
    pub free_frames: *mut *mut vlib_frame_t,
}
impl Default for vlib_frame_size_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vlib_process_event_type_t {
    pub opaque: uword,
}
pub const vlib_process_state_t_VLIB_PROCESS_STATE_NOT_STARTED: vlib_process_state_t = 0;
pub const vlib_process_state_t_VLIB_PROCESS_STATE_RUNNING: vlib_process_state_t = 1;
pub const vlib_process_state_t_VLIB_PROCESS_STATE_SUSPENDED: vlib_process_state_t = 2;
pub const vlib_process_state_t_VLIB_PROCESS_STATE_WAIT_FOR_EVENT: vlib_process_state_t = 3;
pub const vlib_process_state_t_VLIB_PROCESS_STATE_WAIT_FOR_CLOCK: vlib_process_state_t = 4;
pub const vlib_process_state_t_VLIB_PROCESS_STATE_WAIT_FOR_EVENT_OR_CLOCK: vlib_process_state_t = 5;
pub const vlib_process_state_t_VLIB_PROCESS_STATE_WAIT_FOR_ONE_TIME_EVENT: vlib_process_state_t = 6;
pub const vlib_process_state_t_VLIB_PROCESS_STATE_YIELD: vlib_process_state_t = 7;
pub const vlib_process_state_t_VLIB_PROCESS_N_STATES: vlib_process_state_t = 8;
pub type vlib_process_state_t = ::std::os::raw::c_uchar;
pub const vlib_process_restore_reason_t_VLIB_PROCESS_RESTORE_REASON_UNKNOWN:
    vlib_process_restore_reason_t = 0;
pub const vlib_process_restore_reason_t_VLIB_PROCESS_RESTORE_REASON_EVENT:
    vlib_process_restore_reason_t = 1;
pub const vlib_process_restore_reason_t_VLIB_PROCESS_RESTORE_REASON_CLOCK:
    vlib_process_restore_reason_t = 2;
pub const vlib_process_restore_reason_t_VLIB_PROCESS_RESTORE_REASON_TIMED_EVENT:
    vlib_process_restore_reason_t = 3;
pub const vlib_process_restore_reason_t_VLIB_PROCESS_RESTORE_REASON_YIELD:
    vlib_process_restore_reason_t = 4;
pub const vlib_process_restore_reason_t_VLIB_PROCRSS_N_RESTORE_REASON:
    vlib_process_restore_reason_t = 5;
pub type vlib_process_restore_reason_t = ::std::os::raw::c_uchar;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct vlib_process_restore_t {
    pub reason: vlib_process_restore_reason_t,
    pub __bindgen_anon_1: vlib_process_restore_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vlib_process_restore_t__bindgen_ty_1 {
    pub runtime_index: u32_,
    pub timed_event_data_pool_index: u32_,
}
impl Default for vlib_process_restore_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vlib_process_restore_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct vlib_process_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub node_runtime: vlib_node_runtime_t,
    pub return_longjmp: clib_longjmp_t,
    pub resume_longjmp: clib_longjmp_t,
    pub state: vlib_process_state_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub log2_n_stack_bytes: u16_,
    pub suspended_process_frame_index: u32_,
    pub n_suspends: u32_,
    pub pending_event_data_by_type_index: *mut *mut u8_,
    pub non_empty_event_type_bitmap: *mut uword,
    pub one_time_event_type_bitmap: *mut uword,
    pub event_type_index_by_type_opaque: *mut uword,
    pub event_type_pool: *mut vlib_process_event_type_t,
    pub resume_clock_interval: u64_,
    pub stop_timer_handle: u32_,
    pub output_function: vlib_cli_output_function_t,
    pub output_function_arg: uword,
    pub stack: *mut u32_,
}
impl Default for vlib_process_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl vlib_process_t {
    #[inline]
    pub fn event_resume_pending(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_event_resume_pending(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn event_resume_pending_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_event_resume_pending_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(event_resume_pending: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let event_resume_pending: u8 = unsafe { ::std::mem::transmute(event_resume_pending) };
            event_resume_pending as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vlib_one_time_waiting_process_t {
    pub node_index: u32_,
    pub one_time_event: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vlib_signal_timed_event_data_t {
    pub n_data_elts: u16_,
    pub n_data_elt_bytes: u16_,
    pub n_data_bytes: u32_,
    pub process_node_index: u32_,
    pub event_type_index: u32_,
    pub __bindgen_anon_1: vlib_signal_timed_event_data_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vlib_signal_timed_event_data_t__bindgen_ty_1 {
    pub inline_event_data: [u8_; 48usize],
    pub event_data_as_vector: *mut u8_,
}
impl Default for vlib_signal_timed_event_data_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vlib_signal_timed_event_data_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_node_fn_variant_t {
    pub index: clib_march_variant_type_t,
    pub priority: ::std::os::raw::c_int,
    pub suffix: *mut ::std::os::raw::c_char,
    pub desc: *mut ::std::os::raw::c_char,
}
impl Default for vlib_node_fn_variant_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_node_main_t {
    pub nodes: *mut *mut vlib_node_t,
    pub node_by_name: *mut uword,
    pub flags: u32_,
    pub nodes_by_type: [*mut vlib_node_runtime_t; 4usize],
    pub input_node_interrupts: *mut ::std::os::raw::c_void,
    pub pre_input_node_interrupts: *mut ::std::os::raw::c_void,
    pub polling_threshold_vector_length: u32_,
    pub interrupt_threshold_vector_length: u32_,
    pub next_frames: *mut vlib_next_frame_t,
    pub pending_frames: *mut vlib_pending_frame_t,
    pub timing_wheel: *mut ::std::os::raw::c_void,
    pub signal_timed_event_data_pool: *mut vlib_signal_timed_event_data_t,
    pub process_restore_current: *mut vlib_process_restore_t,
    pub process_restore_next: *mut vlib_process_restore_t,
    pub time_next_process_ready: f64_,
    pub processes: *mut *mut vlib_process_t,
    pub current_process_index: u32_,
    pub suspended_process_frames: *mut vlib_pending_frame_t,
    pub recycled_event_data_vectors: *mut *mut ::std::os::raw::c_void,
    pub input_node_counts_by_state: [u32_; 3usize],
    pub frame_sizes: *mut vlib_frame_size_t,
    pub time_last_runtime_stats_clear: f64_,
    pub node_by_error: *mut u32_,
    pub variants: *mut vlib_node_fn_variant_t,
    pub node_fn_default_march_variant: u32_,
    pub node_fn_march_variant_by_suffix: *mut uword,
}
impl Default for vlib_node_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct frame_queue_trace_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub head: u64_,
    pub tail: u64_,
    pub n_in_use: u32_,
    pub nelts: u32_,
    pub written: u32_,
    pub threshold: u32_,
    pub n_vectors: [i32_; 64usize],
}
impl Default for frame_queue_trace_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frame_queue_nelt_counter_t {
    pub count: [u64_; 64usize],
}
impl Default for frame_queue_nelt_counter_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct clib_time_t {
    pub total_cpu_time: u64_,
    pub last_cpu_time: u64_,
    pub clocks_per_second: f64_,
    pub seconds_per_clock: f64_,
    pub init_cpu_time: u64_,
    pub init_reference_time: f64_,
    pub last_verify_cpu_time: u64_,
    pub last_verify_reference_time: f64_,
    pub log2_clocks_per_second: u32_,
    pub log2_clocks_per_frequency_verify: u32_,
    pub damping_constant: f64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct elog_event_t {
    pub __bindgen_anon_1: elog_event_t__bindgen_ty_1,
    pub event_type: u16_,
    pub track: u16_,
    pub data: [u8_; 20usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union elog_event_t__bindgen_ty_1 {
    pub time_cycles: u64_,
    pub time: f64_,
}
impl Default for elog_event_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for elog_event_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct elog_event_type_t<FAM: ?Sized = [*mut ::std::os::raw::c_char; 0]> {
    pub type_index_plus_one: u32_,
    pub enum_strings_vector: *mut *mut ::std::os::raw::c_char,
    pub format: *mut ::std::os::raw::c_char,
    pub format_args: *mut ::std::os::raw::c_char,
    pub function: *mut ::std::os::raw::c_char,
    pub n_enum_strings: u32_,
    pub enum_strings: FAM,
}
impl elog_event_type_t<[*mut ::std::os::raw::c_char]> {}
impl elog_event_type_t<[*mut ::std::os::raw::c_char; 0]> {}
impl Default for elog_event_type_t<[*mut ::std::os::raw::c_char; 0]> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct elog_track_t {
    pub name: *mut ::std::os::raw::c_char,
    pub track_index_plus_one: u32_,
}
impl Default for elog_track_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct elog_time_stamp_t {
    pub cpu: u64_,
    pub os_nsec: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct elog_main_t {
    pub n_total_events: u32_,
    pub n_total_events_disable_limit: u32_,
    pub placeholder_event: elog_event_t,
    pub event_ring_size: uword,
    pub event_ring: *mut elog_event_t,
    pub event_types: *mut elog_event_type_t,
    pub event_type_by_format: *mut uword,
    pub string_table: *mut ::std::os::raw::c_char,
    pub string_table_hash: *mut uword,
    pub string_table_tmp: *mut u8_,
    pub tracks: *mut elog_track_t,
    pub default_track: elog_track_t,
    pub cpu_timer: clib_time_t,
    pub init_time: elog_time_stamp_t,
    pub serialize_time: elog_time_stamp_t,
    pub lock: *mut uword,
    pub nsec_per_cpu_clock: f64_,
    pub events: *mut elog_event_t,
}
impl Default for elog_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct isaac_t {
    pub memory: [uword; 16usize],
    pub a: uword,
    pub b: uword,
    pub c: uword,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clib_random_buffer_t {
    pub ctx: [isaac_t; 2usize],
    pub buffer: *mut uword,
    pub next_read_len: uword,
    pub n_cached_bytes: uword,
    pub __bindgen_anon_1: clib_random_buffer_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union clib_random_buffer_t__bindgen_ty_1 {
    pub cached_bytes: [u8_; 8usize],
    pub cached_word: uword,
}
impl Default for clib_random_buffer_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for clib_random_buffer_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vlib_trace_filter_t {
    pub trace_filter_enable: u8_,
    pub classify_table_index: u32_,
}
pub const vlib_node_runtime_perf_call_type_t_VLIB_NODE_RUNTIME_PERF_BEFORE:
    vlib_node_runtime_perf_call_type_t = 0;
pub const vlib_node_runtime_perf_call_type_t_VLIB_NODE_RUNTIME_PERF_AFTER:
    vlib_node_runtime_perf_call_type_t = 1;
pub const vlib_node_runtime_perf_call_type_t_VLIB_NODE_RUNTIME_PERF_RESET:
    vlib_node_runtime_perf_call_type_t = 2;
pub type vlib_node_runtime_perf_call_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_node_runtime_perf_callback_args_t {
    pub vm: *mut vlib_main_t,
    pub node: *mut vlib_node_runtime_t,
    pub frame: *mut vlib_frame_t,
    pub packets: uword,
    pub cpu_time_now: u64_,
    pub call_type: vlib_node_runtime_perf_call_type_t,
}
impl Default for vlib_node_runtime_perf_callback_args_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vlib_node_runtime_perf_callback_fp_t = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut vlib_node_runtime_perf_callback_data_t,
        args: *mut vlib_node_runtime_perf_callback_args_t,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vlib_node_runtime_perf_callback_data_t {
    pub fp: vlib_node_runtime_perf_callback_fp_t,
    pub u: [vlib_node_runtime_perf_callback_data_t__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vlib_node_runtime_perf_callback_data_t__bindgen_ty_1 {
    pub v: *mut ::std::os::raw::c_void,
    pub u: u64_,
}
impl Default for vlib_node_runtime_perf_callback_data_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vlib_node_runtime_perf_callback_data_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_node_runtime_perf_callback_set_t {
    pub curr: *mut vlib_node_runtime_perf_callback_data_t,
    pub next: *mut vlib_node_runtime_perf_callback_data_t,
    pub spare: *mut vlib_node_runtime_perf_callback_data_t,
    pub lock: *mut clib_spinlock_t,
}
impl Default for vlib_node_runtime_perf_callback_set_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct vlib_main_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub clib_time: clib_time_t,
    pub time_offset: f64_,
    pub time_last_barrier_release: f64_,
    pub cpu_time_last_node_dispatch: u64_,
    pub cpu_time_main_loop_start: u64_,
    pub main_loop_count: u32_,
    pub main_loop_vectors_processed: u32_,
    pub main_loop_nodes_processed: u32_,
    pub internal_node_vectors: u64_,
    pub internal_node_calls: u64_,
    pub internal_node_vectors_last_clear: u64_,
    pub internal_node_calls_last_clear: u64_,
    pub internal_node_last_vectors_per_main_loop: u32_,
    pub vlib_node_runtime_perf_callbacks: vlib_node_runtime_perf_callback_set_t,
    pub dispatch_wrapper_fn: vlib_node_function_t,
    pub main_loop_exit_set: u32_,
    pub main_loop_exit_now: u32_,
    pub main_loop_exit_status: ::std::os::raw::c_int,
    pub __bindgen_padding_0: [u64; 0usize],
    pub main_loop_exit: clib_longjmp_t,
    pub main_loop_error: *mut clib_error_t,
    pub buffer_main: *mut vlib_buffer_main_t,
    pub physmem_main: vlib_physmem_main_t,
    pub node_main: vlib_node_main_t,
    pub trace_main: vlib_trace_main_t,
    pub error_main: vlib_error_main_t,
    pub os_punt_frame: ::std::option::Option<
        unsafe extern "C" fn(
            vm: *mut vlib_main_t,
            node: *mut vlib_node_runtime_t,
            frame: *mut vlib_frame_t,
        ),
    >,
    pub mc_stream_index: u32_,
    pub worker_init_functions_called: *mut uword,
    pub procs_waiting_for_mc_stream_join: *mut vlib_one_time_waiting_process_t,
    pub elog_trace_api_messages: ::std::os::raw::c_int,
    pub elog_trace_cli_commands: ::std::os::raw::c_int,
    pub elog_trace_graph_dispatch: ::std::os::raw::c_int,
    pub elog_trace_graph_circuit: ::std::os::raw::c_int,
    pub elog_trace_graph_circuit_node_index: u32_,
    pub node_call_elog_event_types: *mut elog_event_type_t,
    pub node_return_elog_event_types: *mut elog_event_type_t,
    pub error_elog_event_types: *mut elog_event_type_t,
    pub random_seed: uword,
    pub random_buffer: clib_random_buffer_t,
    pub thread_index: u32_,
    pub cpu_id: u32_,
    pub numa_node: u32_,
    pub queue_signal_pending: u32_,
    pub api_queue_nonempty: u32_,
    pub queue_signal_callback: ::std::option::Option<unsafe extern "C" fn(arg1: *mut vlib_main_t)>,
    pub worker_thread_main_loop_callbacks:
        *mut ::std::option::Option<unsafe extern "C" fn(arg1: *mut vlib_main_t, t: u64_)>,
    pub worker_thread_main_loop_callback_tmp:
        *mut ::std::option::Option<unsafe extern "C" fn(arg1: *mut vlib_main_t, t: u64_)>,
    pub worker_thread_main_loop_callback_lock: clib_spinlock_t,
    pub parked_at_barrier: ::std::os::raw::c_int,
    pub loops_this_reporting_interval: u64_,
    pub loop_interval_end: f64_,
    pub loop_interval_start: f64_,
    pub loops_per_second: f64_,
    pub seconds_per_loop: f64_,
    pub damping_constant: f64_,
    pub barrier_epoch: f64_,
    pub barrier_no_close_before: f64_,
    pub barrier_perf_callbacks: *mut ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut vlib_main_t, t: u64_, leave: ::std::os::raw::c_int),
    >,
    pub barrier_perf_callbacks_tmp: *mut ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut vlib_main_t, t: u64_, leave: ::std::os::raw::c_int),
    >,
    pub check_frame_queues: uword,
    pub pending_rpc_requests: *mut uword,
    pub processing_rpc_requests: *mut uword,
    pub pending_rpc_lock: clib_spinlock_t,
    pub buffer_alloc_success_seed: u32_,
    pub buffer_alloc_success_rate: f64_,
}
impl Default for vlib_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct vlib_global_main_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub vlib_mains: *mut *mut vlib_main_t,
    pub name: *mut ::std::os::raw::c_char,
    pub exec_path: *mut ::std::os::raw::c_char,
    pub argv: *mut *mut u8_,
    pub post_mortem_callbacks: *mut ::std::option::Option<unsafe extern "C" fn()>,
    pub need_vlib_worker_thread_node_runtime_update: ::std::os::raw::c_int,
    pub cli_main: vlib_cli_main_t,
    pub node_registrations: *mut vlib_node_registration_t,
    pub elog_main: elog_main_t,
    pub configured_elog_ring_size: u32_,
    pub trace_filter: vlib_trace_filter_t,
    pub init_function_registrations: *mut _vlib_init_function_list_elt_t,
    pub main_loop_enter_function_registrations: *mut _vlib_init_function_list_elt_t,
    pub main_loop_exit_function_registrations: *mut _vlib_init_function_list_elt_t,
    pub worker_init_function_registrations: *mut _vlib_init_function_list_elt_t,
    pub num_workers_change_function_registrations: *mut _vlib_init_function_list_elt_t,
    pub api_init_function_registrations: *mut _vlib_init_function_list_elt_t,
    pub config_function_registrations: *mut vlib_config_function_runtime_t,
    pub init_functions_called: *mut uword,
}
impl Default for vlib_global_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub static mut vlib_global_main: vlib_global_main_t;
}
unsafe extern "C" {
    pub fn vlib_worker_loop(vm: *mut vlib_main_t);
}
unsafe extern "C" {
    pub fn vlib_exit_with_status(vm: *mut vlib_main_t, status: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn vlib_main(vm: *mut vlib_main_t, input: *mut unformat_input_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut vlib_thread_stacks: *mut *mut u8_;
}
unsafe extern "C" {
    pub fn vlib_app_num_thread_stacks_needed() -> u32_;
}
unsafe extern "C" {
    pub fn vlib_add_del_post_mortem_callback(
        cb: *mut ::std::os::raw::c_void,
        is_add: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vlib_get_main_not_inline() -> *mut vlib_main_t;
}
unsafe extern "C" {
    pub fn vlib_get_elog_main_not_inline() -> *mut elog_main_t;
}
pub type vlib_thread_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_thread_registration_ {
    pub next: *mut vlib_thread_registration_,
    pub name: *mut ::std::os::raw::c_char,
    pub short_name: *mut ::std::os::raw::c_char,
    pub function: vlib_thread_function_t,
    pub mheap_size: uword,
    pub fixed_count: ::std::os::raw::c_int,
    pub count: u32_,
    pub no_data_structure_clone: ::std::os::raw::c_int,
    pub frame_queue_nelts: u32_,
    pub use_pthreads: ::std::os::raw::c_int,
    pub first_index: u32_,
    pub coremask: *mut uword,
}
impl Default for vlib_thread_registration_ {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vlib_thread_registration_t = vlib_thread_registration_;
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct vlib_frame_queue_elt_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub valid: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub n_vectors: u32_,
    pub offset: u32_,
    pub end_of_reset: __IncompleteArrayField<u8_>,
    pub __bindgen_padding_0: [u8; 48usize],
    pub cacheline1: __IncompleteArrayField<u8_>,
    pub buffer_index: [u32_; 256usize],
    pub aux_data: [u32_; 256usize],
}
impl Default for vlib_frame_queue_elt_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl vlib_frame_queue_elt_t {
    #[inline]
    pub fn maybe_trace(&self) -> u32_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_maybe_trace(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn maybe_trace_raw(this: *const Self) -> u32_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_maybe_trace_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(maybe_trace: u32_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let maybe_trace: u32 = unsafe { ::std::mem::transmute(maybe_trace) };
            maybe_trace as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct vlib_worker_thread_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub wait_at_barrier: *mut u32_,
    pub workers_at_barrier: *mut u32_,
    pub __bindgen_padding_0: [u8; 48usize],
    pub cacheline1: __IncompleteArrayField<u8_>,
    pub thread_mheap: *mut ::std::os::raw::c_void,
    pub thread_stack: *mut u8_,
    pub thread_function:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub thread_function_arg: *mut ::std::os::raw::c_void,
    pub recursion_level: i64_,
    pub elog_track: elog_track_t,
    pub instance_id: u32_,
    pub registration: *mut vlib_thread_registration_t,
    pub name: *mut u8_,
    pub barrier_sync_count: u64_,
    pub barrier_elog_enabled: u8_,
    pub barrier_caller: *const ::std::os::raw::c_char,
    pub barrier_context: *const ::std::os::raw::c_char,
    pub node_reforks_required: *mut u32_,
    pub wait_before_barrier: u32_,
    pub workers_before_barrier: u32_,
    pub done_work_before_barrier: u32_,
    pub lwp: ::std::os::raw::c_long,
    pub cpu_id: ::std::os::raw::c_int,
    pub core_id: ::std::os::raw::c_int,
    pub numa_id: ::std::os::raw::c_int,
    pub thread_id: pthread_t,
}
impl Default for vlib_worker_thread_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct vlib_frame_queue_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub elts: *mut vlib_frame_queue_elt_t,
    pub vector_threshold: u64_,
    pub trace: u64_,
    pub nelts: u32_,
    pub __bindgen_padding_0: [u8; 36usize],
    pub cacheline1: __IncompleteArrayField<u8_>,
    pub tail: u64_,
    pub __bindgen_padding_1: [u8; 56usize],
    pub cacheline2: __IncompleteArrayField<u8_>,
    pub head: u64_,
}
impl Default for vlib_frame_queue_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vlib_frame_queue_dequeue_fn_t = ::std::option::Option<
    unsafe extern "C" fn(vm: *mut vlib_main_t, fqm: *mut vlib_frame_queue_main_t_) -> u32_,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_frame_queue_main_t_ {
    pub node_index: u32_,
    pub frame_queue_nelts: u32_,
    pub vlib_frame_queues: *mut *mut vlib_frame_queue_t,
    pub frame_queue_traces: *mut frame_queue_trace_t,
    pub frame_queue_histogram: *mut frame_queue_nelt_counter_t,
    pub frame_queue_dequeue_fn: vlib_frame_queue_dequeue_fn_t,
}
impl Default for vlib_frame_queue_main_t_ {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vlib_frame_queue_main_t = vlib_frame_queue_main_t_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_thread_main_t {
    pub next: *mut vlib_thread_registration_t,
    pub registrations: *mut *mut vlib_thread_registration_t,
    pub thread_registrations_by_name: *mut uword,
    pub worker_threads: *mut vlib_worker_thread_t,
    pub use_pthreads: ::std::os::raw::c_int,
    pub n_vlib_mains: u32_,
    pub n_thread_stacks: u32_,
    pub n_pthreads: u32_,
    pub n_threads: u32_,
    pub skip_cores: u32_,
    pub thread_prefix: *mut u8_,
    pub main_lcore: u32_,
    pub cpu_core_bitmap: *mut uword,
    pub cpu_socket_bitmap: *mut uword,
    pub frame_queue_mains: *mut vlib_frame_queue_main_t,
    pub worker_thread_release: u32_,
    pub sched_policy: u32_,
    pub sched_priority: u32_,
    pub numa_heap_size: uword,
}
impl Default for vlib_thread_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vlib_buffer_enqueue_to_next_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        vm: *mut vlib_main_t,
        node: *mut vlib_node_runtime_t,
        buffers: *mut u32_,
        nexts: *mut u16_,
        count: uword,
    ),
>;
pub type vlib_buffer_enqueue_to_next_with_aux_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        vm: *mut vlib_main_t,
        node: *mut vlib_node_runtime_t,
        buffers: *mut u32_,
        aux_data: *mut u32_,
        nexts: *mut u16_,
        count: uword,
    ),
>;
pub type vlib_buffer_enqueue_to_single_next_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        vm: *mut vlib_main_t,
        node: *mut vlib_node_runtime_t,
        ers: *mut u32_,
        next_index: u16_,
        count: u32_,
    ),
>;
pub type vlib_buffer_enqueue_to_single_next_with_aux_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        vm: *mut vlib_main_t,
        node: *mut vlib_node_runtime_t,
        ers: *mut u32_,
        aux_data: *mut u32_,
        next_index: u16_,
        count: u32_,
    ),
>;
pub type vlib_buffer_enqueue_to_thread_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        vm: *mut vlib_main_t,
        node: *mut vlib_node_runtime_t,
        frame_queue_index: u32_,
        buffer_indices: *mut u32_,
        thread_indices: *mut u16_,
        n_packets: u32_,
        drop_on_congestion: ::std::os::raw::c_int,
    ) -> u32_,
>;
pub type vlib_buffer_enqueue_to_thread_with_aux_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        vm: *mut vlib_main_t,
        node: *mut vlib_node_runtime_t,
        frame_queue_index: u32_,
        buffer_indices: *mut u32_,
        aux: *mut u32_,
        thread_indices: *mut u16_,
        n_packets: u32_,
        drop_on_congestion: ::std::os::raw::c_int,
    ) -> u32_,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vlib_buffer_func_main_t {
    pub buffer_enqueue_to_next_fn: vlib_buffer_enqueue_to_next_fn_t,
    pub buffer_enqueue_to_next_with_aux_fn: vlib_buffer_enqueue_to_next_with_aux_fn_t,
    pub buffer_enqueue_to_single_next_fn: vlib_buffer_enqueue_to_single_next_fn_t,
    pub buffer_enqueue_to_single_next_with_aux_fn: vlib_buffer_enqueue_to_single_next_with_aux_fn_t,
    pub buffer_enqueue_to_thread_fn: vlib_buffer_enqueue_to_thread_fn_t,
    pub buffer_enqueue_to_thread_with_aux_fn: vlib_buffer_enqueue_to_thread_with_aux_fn_t,
}
unsafe extern "C" {
    pub static mut vlib_buffer_func_main: vlib_buffer_func_main_t;
}
unsafe extern "C" {
    pub fn vlib_buffer_length_in_chain_slow_path(
        vm: *mut vlib_main_t,
        b_first: *mut vlib_buffer_t,
    ) -> uword;
}
pub const vlib_buffer_known_state_t_VLIB_BUFFER_UNKNOWN: vlib_buffer_known_state_t = 0;
pub const vlib_buffer_known_state_t_VLIB_BUFFER_KNOWN_FREE: vlib_buffer_known_state_t = 1;
pub const vlib_buffer_known_state_t_VLIB_BUFFER_KNOWN_ALLOCATED: vlib_buffer_known_state_t = 2;
pub type vlib_buffer_known_state_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vlib_buffer_validate_alloc_free(
        vm: *mut vlib_main_t,
        buffers: *mut u32_,
        n_buffers: uword,
        expected_state: vlib_buffer_known_state_t,
    );
}
unsafe extern "C" {
    pub fn vlib_validate_buffer(
        vm: *mut vlib_main_t,
        buffer_index: u32_,
        follow_chain: uword,
    ) -> *mut u8_;
}
unsafe extern "C" {
    pub fn vlib_validate_buffers(
        vm: *mut vlib_main_t,
        buffers: *mut u32_,
        next_buffer_stride: uword,
        n_buffers: uword,
        known_state: vlib_buffer_known_state_t,
        follow_buffer_next: uword,
    ) -> *mut u8_;
}
unsafe extern "C" {
    pub fn vlib_buffer_add_data(
        vm: *mut vlib_main_t,
        buffer_index: *mut u32_,
        data: *mut ::std::os::raw::c_void,
        n_data_bytes: u32_,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vlib_buffer_chain_append_data_with_alloc(
        vm: *mut vlib_main_t,
        first: *mut vlib_buffer_t,
        last: *mut *mut vlib_buffer_t,
        data: *mut ::std::os::raw::c_void,
        data_len: u16_,
    ) -> u16_;
}
unsafe extern "C" {
    pub fn vlib_buffer_chain_validate(vm: *mut vlib_main_t, first: *mut vlib_buffer_t);
}
unsafe extern "C" {
    pub fn format_vlib_buffer(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_vlib_buffer_and_data(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_vlib_buffer_contents(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_vlib_buffer_no_chain(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vlib_packet_template_t {
    pub packet_data: *mut u8_,
    pub min_n_buffers_each_alloc: u32_,
    pub name: *mut u8_,
}
impl Default for vlib_packet_template_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn vlib_packet_template_init(
        vm: *mut vlib_main_t,
        t: *mut vlib_packet_template_t,
        packet_data: *mut ::std::os::raw::c_void,
        n_packet_data_bytes: uword,
        min_n_buffers_each_alloc: uword,
        fmt: *mut ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn vlib_packet_template_get_packet(
        vm: *mut vlib_main_t,
        t: *mut vlib_packet_template_t,
        bi_result: *mut u32_,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub static mut vnet_trace_placeholder: *mut u8_;
}
unsafe extern "C" {
    pub fn vlib_add_handoff_trace(
        vm: *mut vlib_main_t,
        b: *mut vlib_buffer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vlib_add_trace(
        vm: *mut vlib_main_t,
        r: *mut vlib_node_runtime_t,
        b: *mut vlib_buffer_t,
        n_data_bytes: u32_,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn trace_apply_filter(vm: *mut vlib_main_t);
}
unsafe extern "C" {
    pub fn vlib_trace_frame_buffers_only(
        vm: *mut vlib_main_t,
        node: *mut vlib_node_runtime_t,
        buffers: *mut u32_,
        n_buffers: uword,
        next_buffer_stride: uword,
        n_buffer_data_bytes_in_trace: uword,
    );
}
pub const VNET_BUFFER_F_L4_CHECKSUM_COMPUTED: _bindgen_ty_32 = -2147483648;
pub const VNET_BUFFER_F_L4_CHECKSUM_CORRECT: _bindgen_ty_32 = 1073741824;
pub const VNET_BUFFER_F_VLAN_2_DEEP: _bindgen_ty_32 = 536870912;
pub const VNET_BUFFER_F_VLAN_1_DEEP: _bindgen_ty_32 = 268435456;
pub const VNET_BUFFER_F_SPAN_CLONE: _bindgen_ty_32 = 134217728;
pub const VNET_BUFFER_F_LOOP_COUNTER_VALID: _bindgen_ty_32 = 67108864;
pub const VNET_BUFFER_F_LOCALLY_ORIGINATED: _bindgen_ty_32 = 33554432;
pub const VNET_BUFFER_F_IS_IP4: _bindgen_ty_32 = 16777216;
pub const VNET_BUFFER_F_IS_IP6: _bindgen_ty_32 = 8388608;
pub const VNET_BUFFER_F_OFFLOAD: _bindgen_ty_32 = 4194304;
pub const VNET_BUFFER_F_IS_NATED: _bindgen_ty_32 = 2097152;
pub const VNET_BUFFER_F_L2_HDR_OFFSET_VALID: _bindgen_ty_32 = 1048576;
pub const VNET_BUFFER_F_L3_HDR_OFFSET_VALID: _bindgen_ty_32 = 524288;
pub const VNET_BUFFER_F_L4_HDR_OFFSET_VALID: _bindgen_ty_32 = 262144;
pub const VNET_BUFFER_F_FLOW_REPORT: _bindgen_ty_32 = 131072;
pub const VNET_BUFFER_F_IS_DVR: _bindgen_ty_32 = 65536;
pub const VNET_BUFFER_F_QOS_DATA_VALID: _bindgen_ty_32 = 32768;
pub const VNET_BUFFER_F_GSO: _bindgen_ty_32 = 16384;
pub const VNET_BUFFER_F_AVAIL1: _bindgen_ty_32 = 8192;
pub const VNET_BUFFER_F_AVAIL2: _bindgen_ty_32 = 4096;
pub const VNET_BUFFER_F_AVAIL3: _bindgen_ty_32 = 2048;
pub const VNET_BUFFER_F_AVAIL4: _bindgen_ty_32 = 1024;
pub const VNET_BUFFER_F_AVAIL5: _bindgen_ty_32 = 512;
pub const VNET_BUFFER_F_AVAIL6: _bindgen_ty_32 = 256;
pub const VNET_BUFFER_F_AVAIL7: _bindgen_ty_32 = 128;
pub const VNET_BUFFER_F_AVAIL8: _bindgen_ty_32 = 64;
pub const VNET_BUFFER_F_AVAIL9: _bindgen_ty_32 = 32;
pub type _bindgen_ty_32 = ::std::os::raw::c_int;
pub const VNET_BUFFER_F_LOG2_L4_CHECKSUM_COMPUTED: _bindgen_ty_33 = 31;
pub const VNET_BUFFER_F_LOG2_L4_CHECKSUM_CORRECT: _bindgen_ty_33 = 30;
pub const VNET_BUFFER_F_LOG2_VLAN_2_DEEP: _bindgen_ty_33 = 29;
pub const VNET_BUFFER_F_LOG2_VLAN_1_DEEP: _bindgen_ty_33 = 28;
pub const VNET_BUFFER_F_LOG2_SPAN_CLONE: _bindgen_ty_33 = 27;
pub const VNET_BUFFER_F_LOG2_LOOP_COUNTER_VALID: _bindgen_ty_33 = 26;
pub const VNET_BUFFER_F_LOG2_LOCALLY_ORIGINATED: _bindgen_ty_33 = 25;
pub const VNET_BUFFER_F_LOG2_IS_IP4: _bindgen_ty_33 = 24;
pub const VNET_BUFFER_F_LOG2_IS_IP6: _bindgen_ty_33 = 23;
pub const VNET_BUFFER_F_LOG2_OFFLOAD: _bindgen_ty_33 = 22;
pub const VNET_BUFFER_F_LOG2_IS_NATED: _bindgen_ty_33 = 21;
pub const VNET_BUFFER_F_LOG2_L2_HDR_OFFSET_VALID: _bindgen_ty_33 = 20;
pub const VNET_BUFFER_F_LOG2_L3_HDR_OFFSET_VALID: _bindgen_ty_33 = 19;
pub const VNET_BUFFER_F_LOG2_L4_HDR_OFFSET_VALID: _bindgen_ty_33 = 18;
pub const VNET_BUFFER_F_LOG2_FLOW_REPORT: _bindgen_ty_33 = 17;
pub const VNET_BUFFER_F_LOG2_IS_DVR: _bindgen_ty_33 = 16;
pub const VNET_BUFFER_F_LOG2_QOS_DATA_VALID: _bindgen_ty_33 = 15;
pub const VNET_BUFFER_F_LOG2_GSO: _bindgen_ty_33 = 14;
pub const VNET_BUFFER_F_LOG2_AVAIL1: _bindgen_ty_33 = 13;
pub const VNET_BUFFER_F_LOG2_AVAIL2: _bindgen_ty_33 = 12;
pub const VNET_BUFFER_F_LOG2_AVAIL3: _bindgen_ty_33 = 11;
pub const VNET_BUFFER_F_LOG2_AVAIL4: _bindgen_ty_33 = 10;
pub const VNET_BUFFER_F_LOG2_AVAIL5: _bindgen_ty_33 = 9;
pub const VNET_BUFFER_F_LOG2_AVAIL6: _bindgen_ty_33 = 8;
pub const VNET_BUFFER_F_LOG2_AVAIL7: _bindgen_ty_33 = 7;
pub const VNET_BUFFER_F_LOG2_AVAIL8: _bindgen_ty_33 = 6;
pub const VNET_BUFFER_F_LOG2_AVAIL9: _bindgen_ty_33 = 5;
pub type _bindgen_ty_33 = ::std::os::raw::c_uint;
pub const vnet_buffer_oflags_t_VNET_BUFFER_OFFLOAD_F_IP_CKSUM: vnet_buffer_oflags_t = 1;
pub const vnet_buffer_oflags_t_VNET_BUFFER_OFFLOAD_F_TCP_CKSUM: vnet_buffer_oflags_t = 2;
pub const vnet_buffer_oflags_t_VNET_BUFFER_OFFLOAD_F_UDP_CKSUM: vnet_buffer_oflags_t = 4;
pub const vnet_buffer_oflags_t_VNET_BUFFER_OFFLOAD_F_OUTER_IP_CKSUM: vnet_buffer_oflags_t = 8;
pub const vnet_buffer_oflags_t_VNET_BUFFER_OFFLOAD_F_OUTER_UDP_CKSUM: vnet_buffer_oflags_t = 16;
pub const vnet_buffer_oflags_t_VNET_BUFFER_OFFLOAD_F_TNL_VXLAN: vnet_buffer_oflags_t = 32;
pub const vnet_buffer_oflags_t_VNET_BUFFER_OFFLOAD_F_TNL_IPIP: vnet_buffer_oflags_t = 64;
pub type vnet_buffer_oflags_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vnet_buffer_opaque_t {
    pub sw_if_index: [u32_; 2usize],
    pub l2_hdr_offset: i16_,
    pub l3_hdr_offset: i16_,
    pub l4_hdr_offset: i16_,
    pub feature_arc_index: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_anon_1: vnet_buffer_opaque_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vnet_buffer_opaque_t__bindgen_ty_1 {
    pub ip: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1,
    pub mpls: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_2,
    pub l2: vnet_buffer_opaque_t__bindgen_ty_1_opaque_l2,
    pub l2t: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_3,
    pub l2_classify: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_4,
    pub policer: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_5,
    pub ipsec: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_6,
    pub map: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_7,
    pub map_t: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_8,
    pub ip_frag: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_9,
    pub cop: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_10,
    pub lisp: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_11,
    pub tcp: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_12,
    pub snat: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_13,
    pub unused: [u32_; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1 {
    pub adj_index: [u32_; 2usize],
    pub __bindgen_anon_1: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1:
        vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub icmp: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub reass: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub flow_hash: u32_,
    pub __bindgen_anon_1:
        vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub save_rewrite_length: u8_,
    pub __bindgen_anon_2:
        vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    pub save_protocol: u32_,
    pub fib_index: u32_,
}
impl Default
    for vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
{
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2
{
    pub rx_sw_if_index: u32_,
    pub rpf_id: u32_,
}
impl Default
    for vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2
{
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub type_: u8_,
    pub code: u8_,
    pub data: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    pub __bindgen_anon_1:
        vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub __bindgen_anon_2:
        vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
    pub __bindgen_anon_3:
        vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1
{
    pub next_index: u32_,
    pub error_next_index: u32_,
    pub _save_rewrite_length: u8_,
    pub owner_thread_index: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 { pub __bindgen_anon_1 : vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 , }
#[repr(C)]
#[derive(Copy, Clone)]
pub union vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 { pub __bindgen_anon_1 : vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 , pub __bindgen_anon_2 : vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 , }
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
{
    pub l4_src_port: u16_,
    pub l4_dst_port: u16_,
    pub tcp_ack_number: u32_,
    pub save_rewrite_length: u8_,
    pub ip_proto: u8_,
    pub icmp_type_or_tcp_flags: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tcp_seq_number: u32_,
}
impl vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 { # [inline] pub fn is_non_first_fragment (& self) -> u8_ { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (0usize , 1u8) as u8) } } # [inline] pub fn set_is_non_first_fragment (& mut self , val : u8_) { unsafe { let val : u8 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (0usize , 1u8 , val as u64) } } # [inline] pub unsafe fn is_non_first_fragment_raw (this : * const Self) -> u8_ { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 0usize , 1u8 ,) as u8) } } # [inline] pub unsafe fn set_is_non_first_fragment_raw (this : * mut Self , val : u8_) { unsafe { let val : u8 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 0usize , 1u8 , val as u64 ,) } } # [inline] pub fn l4_hdr_truncated (& self) -> u8_ { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (1usize , 1u8) as u8) } } # [inline] pub fn set_l4_hdr_truncated (& mut self , val : u8_) { unsafe { let val : u8 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (1usize , 1u8 , val as u64) } } # [inline] pub unsafe fn l4_hdr_truncated_raw (this : * const Self) -> u8_ { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 1usize , 1u8 ,) as u8) } } # [inline] pub unsafe fn set_l4_hdr_truncated_raw (this : * mut Self , val : u8_) { unsafe { let val : u8 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 1usize , 1u8 , val as u64 ,) } } # [inline] pub fn unused (& self) -> u8_ { unsafe { :: std :: mem :: transmute (self . _bitfield_1 . get (2usize , 6u8) as u8) } } # [inline] pub fn set_unused (& mut self , val : u8_) { unsafe { let val : u8 = :: std :: mem :: transmute (val) ; self . _bitfield_1 . set (2usize , 6u8 , val as u64) } } # [inline] pub unsafe fn unused_raw (this : * const Self) -> u8_ { unsafe { :: std :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , 2usize , 6u8 ,) as u8) } } # [inline] pub unsafe fn set_unused_raw (this : * mut Self , val : u8_) { unsafe { let val : u8 = :: std :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] > > :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , 2usize , 6u8 , val as u64 ,) } } # [inline] pub fn new_bitfield_1 (is_non_first_fragment : u8_ , l4_hdr_truncated : u8_ , unused : u8_) -> __BindgenBitfieldUnit < [u8 ; 1usize] > { let mut __bindgen_bitfield_unit : __BindgenBitfieldUnit < [u8 ; 1usize] > = Default :: default () ; __bindgen_bitfield_unit . set (0usize , 1u8 , { let is_non_first_fragment : u8 = unsafe { :: std :: mem :: transmute (is_non_first_fragment) } ; is_non_first_fragment as u64 }) ; __bindgen_bitfield_unit . set (1usize , 1u8 , { let l4_hdr_truncated : u8 = unsafe { :: std :: mem :: transmute (l4_hdr_truncated) } ; l4_hdr_truncated as u64 }) ; __bindgen_bitfield_unit . set (2usize , 6u8 , { let unused : u8 = unsafe { :: std :: mem :: transmute (unused) } ; unused as u64 }) ; __bindgen_bitfield_unit } }
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2
{
    pub estimated_mtu: u16_,
}
impl Default for vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2__bindgen_ty_1 { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } }
impl Default
    for vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2
{
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3__bindgen_ty_3
{
    pub fragment_first: u16_,
    pub fragment_last: u16_,
    pub range_first: u16_,
    pub range_last: u16_,
    pub next_range_bi: u32_,
    pub ip6_frag_hdr_offset: u16_,
}
impl Default for vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_2 {
    pub pad: [u32_; 3usize],
    pub ttl: u8_,
    pub exp: u8_,
    pub first: u8_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub save_rewrite_length: u8_,
    pub mpls_hdr_length: u8_,
    pub bier: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub n_bytes: u8_,
}
impl vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn pyld_proto(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pyld_proto(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pyld_proto_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_pyld_proto_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsvd(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsvd_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                5u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_rsvd_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(pyld_proto: u8_, rsvd: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pyld_proto: u8 = unsafe { ::std::mem::transmute(pyld_proto) };
            pyld_proto as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let rsvd: u8 = unsafe { ::std::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1_opaque_l2 {
    pub feature_bitmap: u32_,
    pub bd_index: u16_,
    pub l2fib_sn: u16_,
    pub l2_len: u8_,
    pub shg: u8_,
    pub bd_age: u8_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_3 {
    pub pad: [u32_; 4usize],
    pub next_index: u8_,
    pub session_index: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_4 {
    pub pad: [u32_; 4usize],
    pub __bindgen_anon_1: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub hash: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub table_index: u32_,
    pub opaque_index: u32_,
}
impl Default for vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_5 {
    pub pad: [u32_; 5usize],
    pub index: u32_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_6 {
    pub __pad: [u32_; 3usize],
    pub sad_index: u32_,
    pub protect_index: u32_,
    pub thread_index: u16_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_7 {
    pub mtu: u16_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_8 {
    pub map_domain_index: u32_,
    pub v6: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1,
    pub checksum_offset: u16_,
    pub mtu: u16_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1 {
    pub saddr: u32_,
    pub daddr: u32_,
    pub frag_offset: u16_,
    pub l4_offset: u16_,
    pub l4_protocol: u8_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_9 {
    pub pad: [u32_; 2usize],
    pub mtu: u16_,
    pub next_index: u8_,
    pub flags: u8_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_10 {
    pub current_config_index: u32_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_11 {
    pub overlay_afi: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_12 {
    pub connection_index: u32_,
    pub __bindgen_anon_1: vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1,
    pub seq_end: u32_,
    pub ack_number: u32_,
    pub hdr_offset: u16_,
    pub data_offset: u16_,
    pub data_len: u16_,
    pub flags: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1 {
    pub seq_number: u32_,
    pub next_node_opaque: u32_,
}
impl Default for vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque_t__bindgen_ty_1__bindgen_ty_13 {
    pub flags: u32_,
    pub required_thread_index: u32_,
}
impl Default for vnet_buffer_opaque_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vnet_buffer_opaque_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl vnet_buffer_opaque_t {
    #[inline]
    pub fn oflags(&self) -> vnet_buffer_oflags_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_oflags(&mut self, val: vnet_buffer_oflags_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn oflags_raw(this: *const Self) -> vnet_buffer_oflags_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_oflags_raw(this: *mut Self, val: vnet_buffer_oflags_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(oflags: vnet_buffer_oflags_t) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let oflags: u32 = unsafe { ::std::mem::transmute(oflags) };
            oflags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vnet_buffer_opaque2_t {
    pub qos: vnet_buffer_opaque2_t__bindgen_ty_1,
    pub loop_counter: u8_,
    pub pad: [u8_; 5usize],
    pub __bindgen_anon_1: vnet_buffer_opaque2_t__bindgen_ty_2,
    pub nat: vnet_buffer_opaque2_t__bindgen_ty_3,
    pub ip: vnet_buffer_opaque2_t__bindgen_ty_4,
    pub unused: [u32_; 5usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque2_t__bindgen_ty_1 {
    pub bits: u8_,
    pub source: u8_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque2_t__bindgen_ty_2 {
    pub gso_size: u16_,
    pub gso_l4_hdr_sz: u16_,
    pub outer_l3_hdr_offset: i16_,
    pub outer_l4_hdr_offset: i16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vnet_buffer_opaque2_t__bindgen_ty_3 {
    pub arc_next: u32_,
    pub __bindgen_anon_1: vnet_buffer_opaque2_t__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vnet_buffer_opaque2_t__bindgen_ty_3__bindgen_ty_1 {
    pub cached_session_index: u32_,
    pub cached_dst_nat_session_index: u32_,
}
impl Default for vnet_buffer_opaque2_t__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vnet_buffer_opaque2_t__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque2_t__bindgen_ty_4 {
    pub reass: vnet_buffer_opaque2_t__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_buffer_opaque2_t__bindgen_ty_4__bindgen_ty_1 {
    pub thread_index: u32_,
    pub pool_index: u32_,
    pub id: u32_,
}
impl Default for vnet_buffer_opaque2_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn format_vnet_buffer_no_chain(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_vnet_buffer(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_vnet_buffer_offload(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_vnet_buffer_flags(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_vnet_buffer_opaque(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_vnet_buffer_opaque2(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnet_config_feature_t {
    pub feature_index: u32_,
    pub node_index: u32_,
    pub next_index: u32_,
    pub feature_config: *mut u32_,
}
impl Default for vnet_config_feature_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnet_config_t {
    pub features: *mut vnet_config_feature_t,
    pub config_string_vector: *mut u32_,
    pub config_string_heap_index: u32_,
    pub config_string_heap_handle: u32_,
    pub index: u32_,
    pub reference_count: u32_,
}
impl Default for vnet_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnet_config_main_t {
    pub config_pool: *mut vnet_config_t,
    pub config_string_hash: *mut uword,
    pub config_string_heap: *mut u32_,
    pub start_node_indices: *mut u32_,
    pub end_node_indices_by_user_index: *mut u32_,
    pub default_end_node_index: u32_,
    pub node_index_by_feature_index: *mut u32_,
    pub config_pool_index_by_user_index: *mut u32_,
    pub config_string_temp: *mut u32_,
}
impl Default for vnet_config_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const vnet_hash_fn_type_t_VNET_HASH_FN_TYPE_ETHERNET: vnet_hash_fn_type_t = 0;
pub const vnet_hash_fn_type_t_VNET_HASH_FN_TYPE_IP: vnet_hash_fn_type_t = 1;
pub const vnet_hash_fn_type_t_VNET_HASH_FN_TYPE_N: vnet_hash_fn_type_t = 2;
pub type vnet_hash_fn_type_t = ::std::os::raw::c_uint;
pub type vnet_hash_fn_t = ::std::option::Option<
    unsafe extern "C" fn(p: *mut *mut ::std::os::raw::c_void, h: *mut u32_, n_packets: u32_),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip46_address_t_ {
    _unused: [u8; 0],
}
pub const vnet_hw_if_rx_mode_VNET_HW_IF_RX_MODE_UNKNOWN: vnet_hw_if_rx_mode = 0;
pub const vnet_hw_if_rx_mode_VNET_HW_IF_RX_MODE_POLLING: vnet_hw_if_rx_mode = 1;
pub const vnet_hw_if_rx_mode_VNET_HW_IF_RX_MODE_INTERRUPT: vnet_hw_if_rx_mode = 2;
pub const vnet_hw_if_rx_mode_VNET_HW_IF_RX_MODE_ADAPTIVE: vnet_hw_if_rx_mode = 3;
pub const vnet_hw_if_rx_mode_VNET_HW_IF_RX_MODE_DEFAULT: vnet_hw_if_rx_mode = 4;
pub const vnet_hw_if_rx_mode_VNET_HW_IF_NUM_RX_MODES: vnet_hw_if_rx_mode = 5;
pub type vnet_hw_if_rx_mode = ::std::os::raw::c_uint;
pub type vnet_interface_function_t = ::std::option::Option<
    unsafe extern "C" fn(vnm: *mut vnet_main_t, if_index: u32_, flags: u32_) -> *mut clib_error_t,
>;
pub type vnet_subif_add_del_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        vnm: *mut vnet_main_t,
        if_index: u32_,
        template: *mut vnet_sw_interface_t,
        is_add: ::std::os::raw::c_int,
    ) -> *mut clib_error_t,
>;
pub type vnet_interface_set_max_frame_size_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        vnm: *mut vnet_main_t,
        hi: *mut vnet_hw_interface_t,
        mtu: u32_,
    ) -> *mut clib_error_t,
>;
pub type vnet_interface_set_mac_address_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        hi: *mut vnet_hw_interface_t,
        old_address: *const u8_,
        new_address: *const u8_,
    ) -> *mut clib_error_t,
>;
pub type vnet_interface_add_del_mac_address_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        hi: *mut vnet_hw_interface_t,
        address: *const u8_,
        is_add: u8_,
    ) -> *mut clib_error_t,
>;
pub type vnet_interface_set_rx_mode_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        vnm: *mut vnet_main_t,
        if_index: u32_,
        queue_id: u32_,
        mode: vnet_hw_if_rx_mode,
    ) -> *mut clib_error_t,
>;
pub type vnet_interface_set_l2_mode_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        vnm: *mut vnet_main_t,
        hi: *mut vnet_hw_interface_t,
        l2_if_adjust: i32_,
    ) -> *mut clib_error_t,
>;
pub type vnet_interface_rss_queues_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        vnm: *mut vnet_main_t,
        hi: *mut vnet_hw_interface_t,
        bitmap: *mut clib_bitmap_t,
    ) -> *mut clib_error_t,
>;
pub const vnet_flow_dev_op_t_VNET_FLOW_DEV_OP_ADD_FLOW: vnet_flow_dev_op_t = 0;
pub const vnet_flow_dev_op_t_VNET_FLOW_DEV_OP_DEL_FLOW: vnet_flow_dev_op_t = 1;
pub const vnet_flow_dev_op_t_VNET_FLOW_DEV_OP_GET_COUNTER: vnet_flow_dev_op_t = 2;
pub const vnet_flow_dev_op_t_VNET_FLOW_DEV_OP_RESET_COUNTER: vnet_flow_dev_op_t = 3;
pub type vnet_flow_dev_op_t = ::std::os::raw::c_uint;
pub type vnet_flow_dev_ops_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        vnm: *mut vnet_main_t,
        op: vnet_flow_dev_op_t,
        hw_if_index: u32_,
        index: u32_,
        private_data: *mut uword,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vnet_interface_function_list_elt {
    pub next_interface_function: *mut _vnet_interface_function_list_elt,
    pub fp: ::std::option::Option<
        unsafe extern "C" fn(
            vnm: *mut vnet_main_t,
            if_index: u32_,
            flags: u32_,
        ) -> *mut clib_error_t,
    >,
}
impl Default for _vnet_interface_function_list_elt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _vnet_interface_function_list_elt_t = _vnet_interface_function_list_elt;
pub type vnet_dev_class_ip_tunnel_desc_t = ::std::option::Option<
    unsafe extern "C" fn(
        sw_if_index: u32_,
        src: *mut ip46_address_t_,
        dst: *mut ip46_address_t_,
        is_l2: *mut u8_,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vnet_device_class {
    pub index: u32_,
    pub name: *mut ::std::os::raw::c_char,
    pub interface_add_del_function: vnet_interface_function_t,
    pub admin_up_down_function: vnet_interface_function_t,
    pub subif_add_del_function: vnet_subif_add_del_function_t,
    pub rx_mode_change_function: vnet_interface_set_rx_mode_function_t,
    pub set_l2_mode_function: vnet_interface_set_l2_mode_function_t,
    pub redistribute: u32_,
    pub tx_function: vlib_node_function_t,
    pub tx_fn_registrations: *mut vlib_node_fn_registration_t,
    pub tx_function_error_strings: *mut *mut ::std::os::raw::c_char,
    pub tx_function_error_counters: *mut vlib_error_desc_t,
    pub tx_function_n_errors: u32_,
    pub name_renumber: ::std::option::Option<
        unsafe extern "C" fn(
            hi: *mut vnet_hw_interface_t,
            new_dev_instance: u32_,
        ) -> ::std::os::raw::c_int,
    >,
    pub flow_ops_function: vnet_flow_dev_ops_function_t,
    pub format_device_name: format_function_t,
    pub unformat_device_name: unformat_function_t,
    pub format_device: format_function_t,
    pub format_tx_trace: format_function_t,
    pub format_flow: format_function_t,
    pub ip_tun_desc: vnet_dev_class_ip_tunnel_desc_t,
    pub clear_counters: ::std::option::Option<unsafe extern "C" fn(dev_class_instance: u32_)>,
    pub is_valid_class_for_interface: ::std::option::Option<
        unsafe extern "C" fn(
            vnm: *mut vnet_main_t,
            hw_if_index: u32_,
            hw_class_index: u32_,
        ) -> uword,
    >,
    pub hw_class_change: ::std::option::Option<
        unsafe extern "C" fn(vnm: *mut vnet_main_t, hw_if_index: u32_, new_hw_class_index: u32_),
    >,
    pub rx_redirect_to_node: ::std::option::Option<
        unsafe extern "C" fn(vnm: *mut vnet_main_t, hw_if_index: u32_, node_index: u32_),
    >,
    pub next_class_registration: *mut _vnet_device_class,
    pub mac_addr_change_function: vnet_interface_set_mac_address_function_t,
    pub mac_addr_add_del_function: vnet_interface_add_del_mac_address_function_t,
    pub set_rss_queues_function: vnet_interface_rss_queues_set_t,
}
impl Default for _vnet_device_class {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vnet_device_class_t = _vnet_device_class;
pub const vnet_link_t__VNET_LINK_IP4: vnet_link_t_ = 0;
pub const vnet_link_t__VNET_LINK_IP6: vnet_link_t_ = 1;
pub const vnet_link_t__VNET_LINK_MPLS: vnet_link_t_ = 2;
pub const vnet_link_t__VNET_LINK_ETHERNET: vnet_link_t_ = 3;
pub const vnet_link_t__VNET_LINK_ARP: vnet_link_t_ = 4;
pub const vnet_link_t__VNET_LINK_NSH: vnet_link_t_ = 5;
pub type vnet_link_t_ = ::std::os::raw::c_uchar;
pub use self::vnet_link_t_ as vnet_link_t;
pub const vnet_hw_interface_class_flags_t__VNET_HW_INTERFACE_CLASS_FLAG_P2P:
    vnet_hw_interface_class_flags_t_ = 1;
pub const vnet_hw_interface_class_flags_t__VNET_HW_INTERFACE_CLASS_FLAG_NBMA:
    vnet_hw_interface_class_flags_t_ = 2;
pub type vnet_hw_interface_class_flags_t_ = ::std::os::raw::c_uint;
pub use self::vnet_hw_interface_class_flags_t_ as vnet_hw_interface_class_flags_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vnet_hw_interface_class {
    pub index: u32_,
    pub name: *mut ::std::os::raw::c_char,
    pub flags: vnet_hw_interface_class_flags_t,
    pub tx_hash_fn_type: vnet_hash_fn_type_t,
    pub interface_add_del_function: vnet_interface_function_t,
    pub admin_up_down_function: vnet_interface_function_t,
    pub link_up_down_function: vnet_interface_function_t,
    pub mac_addr_change_function: vnet_interface_set_mac_address_function_t,
    pub mac_addr_add_del_function: vnet_interface_add_del_mac_address_function_t,
    pub set_max_frame_size: vnet_interface_set_max_frame_size_function_t,
    pub format_interface_name: format_function_t,
    pub format_address: format_function_t,
    pub format_header: format_function_t,
    pub format_device: format_function_t,
    pub unformat_hw_address: unformat_function_t,
    pub unformat_header: unformat_function_t,
    pub build_rewrite: ::std::option::Option<
        unsafe extern "C" fn(
            vnm: *mut vnet_main_t,
            sw_if_index: u32_,
            link_type: vnet_link_t,
            dst_hw_address: *const ::std::os::raw::c_void,
        ) -> *mut u8_,
    >,
    pub update_adjacency: ::std::option::Option<
        unsafe extern "C" fn(vnm: *mut vnet_main_t, sw_if_index: u32_, adj_index: u32_),
    >,
    pub is_valid_class_for_interface: ::std::option::Option<
        unsafe extern "C" fn(
            vnm: *mut vnet_main_t,
            hw_if_index: u32_,
            hw_class_index: u32_,
        ) -> uword,
    >,
    pub hw_class_change: ::std::option::Option<
        unsafe extern "C" fn(
            vnm: *mut vnet_main_t,
            hw_if_index: u32_,
            old_class_index: u32_,
            new_class_index: u32_,
        ),
    >,
    pub next_class_registration: *mut _vnet_hw_interface_class,
}
impl Default for _vnet_hw_interface_class {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vnet_hw_interface_class_t = _vnet_hw_interface_class;
pub const vnet_hw_interface_flags_t__VNET_HW_INTERFACE_FLAG_NONE: vnet_hw_interface_flags_t_ = 0;
pub const vnet_hw_interface_flags_t__VNET_HW_INTERFACE_FLAG_LINK_UP: vnet_hw_interface_flags_t_ = 1;
pub const vnet_hw_interface_flags_t__VNET_HW_INTERFACE_FLAG_HALF_DUPLEX:
    vnet_hw_interface_flags_t_ = 2;
pub const vnet_hw_interface_flags_t__VNET_HW_INTERFACE_FLAG_FULL_DUPLEX:
    vnet_hw_interface_flags_t_ = 4;
pub const vnet_hw_interface_flags_t__VNET_HW_INTERFACE_FLAG_NBMA: vnet_hw_interface_flags_t_ =
    524288;
pub type vnet_hw_interface_flags_t_ = ::std::os::raw::c_uint;
pub use self::vnet_hw_interface_flags_t_ as vnet_hw_interface_flags_t;
pub const vnet_hw_if_caps_t__VNET_HW_INTERFACE_CAP_NONE: vnet_hw_if_caps_t_ = 0;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_TX_IP4_CKSUM: vnet_hw_if_caps_t_ = 1;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_TX_TCP_CKSUM: vnet_hw_if_caps_t_ = 2;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_TX_UDP_CKSUM: vnet_hw_if_caps_t_ = 4;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_TX_IP4_OUTER_CKSUM: vnet_hw_if_caps_t_ = 8;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_TX_UDP_OUTER_CKSUM: vnet_hw_if_caps_t_ = 16;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_RX_IP4_CKSUM: vnet_hw_if_caps_t_ = 32;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_RX_TCP_CKSUM: vnet_hw_if_caps_t_ = 64;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_RX_UDP_CKSUM: vnet_hw_if_caps_t_ = 128;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_RX_IP4_OUTER_CKSUM: vnet_hw_if_caps_t_ = 256;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_RX_UDP_OUTER_CKSUM: vnet_hw_if_caps_t_ = 512;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_TCP_GSO: vnet_hw_if_caps_t_ = 1024;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_UDP_GSO: vnet_hw_if_caps_t_ = 2048;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_VXLAN_TNL_GSO: vnet_hw_if_caps_t_ = 4096;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_IPIP_TNL_GSO: vnet_hw_if_caps_t_ = 8192;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_GENEVE_TNL_GSO: vnet_hw_if_caps_t_ = 16384;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_GRE_TNL_GSO: vnet_hw_if_caps_t_ = 32768;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_UDP_TNL_GSO: vnet_hw_if_caps_t_ = 65536;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_IP_TNL_GSO: vnet_hw_if_caps_t_ = 131072;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_TCP_LRO: vnet_hw_if_caps_t_ = 262144;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_INT_MODE: vnet_hw_if_caps_t_ = 1073741824;
pub const vnet_hw_if_caps_t__VNET_HW_IF_CAP_MAC_FILTER: vnet_hw_if_caps_t_ = -2147483648;
pub type vnet_hw_if_caps_t_ = ::std::os::raw::c_int;
pub use self::vnet_hw_if_caps_t_ as vnet_hw_if_caps_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnet_hw_if_rx_queue_t {
    pub hw_if_index: u32_,
    pub dev_instance: u32_,
    pub thread_index: u32_,
    pub file_index: u32_,
    pub queue_id: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for vnet_hw_if_rx_queue_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl vnet_hw_if_rx_queue_t {
    #[inline]
    pub fn mode(&self) -> vnet_hw_if_rx_mode {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: vnet_hw_if_rx_mode) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mode_raw(this: *const Self) -> vnet_hw_if_rx_mode {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mode_raw(this: *mut Self, val: vnet_hw_if_rx_mode) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(mode: vnet_hw_if_rx_mode) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mode: u32 = unsafe { ::std::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnet_hw_if_tx_queue_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub hw_if_index: u32_,
    pub queue_id: u32_,
    pub threads: *mut clib_bitmap_t,
}
impl Default for vnet_hw_if_tx_queue_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl vnet_hw_if_tx_queue_t {
    #[inline]
    pub fn shared_queue(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shared_queue(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shared_queue_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_shared_queue_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(shared_queue: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shared_queue: u8 = unsafe { ::std::mem::transmute(shared_queue) };
            shared_queue as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const vnet_hw_if_tx_frame_hint_t_VNET_HW_IF_TX_FRAME_HINT_NOT_CHAINED:
    vnet_hw_if_tx_frame_hint_t = 1;
pub const vnet_hw_if_tx_frame_hint_t_VNET_HW_IF_TX_FRAME_HINT_NO_GSO: vnet_hw_if_tx_frame_hint_t =
    2;
pub const vnet_hw_if_tx_frame_hint_t_VNET_HW_IF_TX_FRAME_HINT_NO_CKSUM_OFFLOAD:
    vnet_hw_if_tx_frame_hint_t = 4;
pub type vnet_hw_if_tx_frame_hint_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnet_hw_if_tx_frame_t {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub queue_id: u32_,
}
impl Default for vnet_hw_if_tx_frame_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl vnet_hw_if_tx_frame_t {
    #[inline]
    pub fn shared_queue(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_shared_queue(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shared_queue_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_shared_queue_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hints(&self) -> vnet_hw_if_tx_frame_hint_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hints(&mut self, val: vnet_hw_if_tx_frame_hint_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hints_raw(this: *const Self) -> vnet_hw_if_tx_frame_hint_t {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hints_raw(this: *mut Self, val: vnet_hw_if_tx_frame_hint_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        shared_queue: u8_,
        hints: vnet_hw_if_tx_frame_hint_t,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shared_queue: u8 = unsafe { ::std::mem::transmute(shared_queue) };
            shared_queue as u64
        });
        __bindgen_bitfield_unit.set(1usize, 16u8, {
            let hints: u32 = unsafe { ::std::mem::transmute(hints) };
            hints as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct vnet_hw_if_output_node_runtime_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub frame: *mut vnet_hw_if_tx_frame_t,
    pub lookup_table: *mut u32_,
    pub n_queues: u32_,
}
impl Default for vnet_hw_if_output_node_runtime_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct vnet_hw_interface_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub flags: vnet_hw_interface_flags_t,
    pub caps: vnet_hw_if_caps_t,
    pub hw_address: *mut u8_,
    pub output_node_index: u32_,
    pub tx_node_index: u32_,
    pub if_out_arc_end_node_next_index: u32_,
    pub dev_class_index: u32_,
    pub dev_instance: u32_,
    pub hw_class_index: u32_,
    pub hw_instance: u32_,
    pub hw_if_index: u32_,
    pub sw_if_index: u32_,
    pub output_node_thread_runtimes: *mut vnet_hw_if_output_node_runtime_t,
    pub cacheline1: __IncompleteArrayField<u8_>,
    pub name: *mut u8_,
    pub link_speed: u32_,
    pub output_node_next_index: u32_,
    pub hf: vnet_hash_fn_t,
    pub max_rate_bits_per_sec: f64_,
    pub min_frame_size: u32_,
    pub max_frame_size: u32_,
    pub frame_overhead: u16_,
    pub sub_interface_sw_if_index_by_id: *mut uword,
    pub l2_if_count: u32_,
    pub l3_if_count: u32_,
    pub bond_info: *mut uword,
    pub input_node_index: u32_,
    pub default_rx_mode: vnet_hw_if_rx_mode,
    pub rx_queue_indices: *mut u32_,
    pub tx_queue_indices: *mut u32_,
    pub numa_node: u8_,
    pub rss_queues: *mut clib_bitmap_t,
    pub n_trace: i32_,
    pub trace_classify_table_index: u32_,
}
impl Default for vnet_hw_interface_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const vnet_sw_interface_type_t_VNET_SW_INTERFACE_TYPE_HARDWARE: vnet_sw_interface_type_t = 0;
pub const vnet_sw_interface_type_t_VNET_SW_INTERFACE_TYPE_SUB: vnet_sw_interface_type_t = 1;
pub const vnet_sw_interface_type_t_VNET_SW_INTERFACE_TYPE_P2P: vnet_sw_interface_type_t = 2;
pub const vnet_sw_interface_type_t_VNET_SW_INTERFACE_TYPE_PIPE: vnet_sw_interface_type_t = 3;
pub type vnet_sw_interface_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vnet_sub_interface_t {
    pub id: u32_,
    pub eth: vnet_sub_interface_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vnet_sub_interface_t__bindgen_ty_1 {
    pub outer_vlan_id: u16_,
    pub inner_vlan_id: u16_,
    pub __bindgen_anon_1: vnet_sub_interface_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vnet_sub_interface_t__bindgen_ty_1__bindgen_ty_1 {
    pub raw_flags: u16_,
    pub flags: vnet_sub_interface_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_sub_interface_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl vnet_sub_interface_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn no_tags(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_no_tags(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn no_tags_raw(this: *const Self) -> u16_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_no_tags_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn one_tag(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_one_tag(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn one_tag_raw(this: *const Self) -> u16_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_one_tag_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn two_tags(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_two_tags(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn two_tags_raw(this: *const Self) -> u16_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_two_tags_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dot1ad(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dot1ad(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dot1ad_raw(this: *const Self) -> u16_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_dot1ad_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn exact_match(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_exact_match(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn exact_match_raw(this: *const Self) -> u16_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_exact_match_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn default_sub(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_default_sub(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn default_sub_raw(this: *const Self) -> u16_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_default_sub_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_vlan_id_any(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_outer_vlan_id_any(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_vlan_id_any_raw(this: *const Self) -> u16_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_outer_vlan_id_any_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inner_vlan_id_any(&self) -> u16_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_inner_vlan_id_any(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_vlan_id_any_raw(this: *const Self) -> u16_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_inner_vlan_id_any_raw(this: *mut Self, val: u16_) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        no_tags: u16_,
        one_tag: u16_,
        two_tags: u16_,
        dot1ad: u16_,
        exact_match: u16_,
        default_sub: u16_,
        outer_vlan_id_any: u16_,
        inner_vlan_id_any: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let no_tags: u16 = unsafe { ::std::mem::transmute(no_tags) };
            no_tags as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let one_tag: u16 = unsafe { ::std::mem::transmute(one_tag) };
            one_tag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let two_tags: u16 = unsafe { ::std::mem::transmute(two_tags) };
            two_tags as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dot1ad: u16 = unsafe { ::std::mem::transmute(dot1ad) };
            dot1ad as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let exact_match: u16 = unsafe { ::std::mem::transmute(exact_match) };
            exact_match as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let default_sub: u16 = unsafe { ::std::mem::transmute(default_sub) };
            default_sub as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let outer_vlan_id_any: u16 = unsafe { ::std::mem::transmute(outer_vlan_id_any) };
            outer_vlan_id_any as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let inner_vlan_id_any: u16 = unsafe { ::std::mem::transmute(inner_vlan_id_any) };
            inner_vlan_id_any as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for vnet_sub_interface_t__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vnet_sub_interface_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for vnet_sub_interface_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_p2p_sub_interface_t {
    pub id: u32_,
    pub pool_index: u32_,
    pub client_mac: [u8_; 6usize],
}
pub const vnet_flood_class_t_VNET_FLOOD_CLASS_BVI: vnet_flood_class_t = 0;
pub const vnet_flood_class_t_VNET_FLOOD_CLASS_NORMAL: vnet_flood_class_t = 1;
pub const vnet_flood_class_t_VNET_FLOOD_CLASS_TUNNEL_MASTER: vnet_flood_class_t = 2;
pub const vnet_flood_class_t_VNET_FLOOD_CLASS_TUNNEL_NORMAL: vnet_flood_class_t = 3;
pub const vnet_flood_class_t_VNET_FLOOD_CLASS_NO_FLOOD: vnet_flood_class_t = 4;
pub type vnet_flood_class_t = ::std::os::raw::c_uint;
pub const vnet_sw_interface_flags_t__VNET_SW_INTERFACE_FLAG_NONE: vnet_sw_interface_flags_t_ = 0;
pub const vnet_sw_interface_flags_t__VNET_SW_INTERFACE_FLAG_ADMIN_UP: vnet_sw_interface_flags_t_ =
    1;
pub const vnet_sw_interface_flags_t__VNET_SW_INTERFACE_FLAG_PUNT: vnet_sw_interface_flags_t_ = 2;
pub const vnet_sw_interface_flags_t____VNET_SW_INTERFACE_FLAG_UNSUED: vnet_sw_interface_flags_t_ =
    4;
pub const vnet_sw_interface_flags_t__VNET_SW_INTERFACE_FLAG_UNNUMBERED: vnet_sw_interface_flags_t_ =
    8;
pub const vnet_sw_interface_flags_t____VNET_SW_INTERFACE_FLAG_UNUSED2: vnet_sw_interface_flags_t_ =
    16;
pub const vnet_sw_interface_flags_t__VNET_SW_INTERFACE_FLAG_HIDDEN: vnet_sw_interface_flags_t_ = 32;
pub const vnet_sw_interface_flags_t__VNET_SW_INTERFACE_FLAG_ERROR: vnet_sw_interface_flags_t_ = 64;
pub const vnet_sw_interface_flags_t__VNET_SW_INTERFACE_FLAG_DIRECTED_BCAST:
    vnet_sw_interface_flags_t_ = 128;
pub type vnet_sw_interface_flags_t_ = ::std::os::raw::c_uchar;
pub use self::vnet_sw_interface_flags_t_ as vnet_sw_interface_flags_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vnet_hw_interface_nodes_t {
    pub output_node_index: u32_,
    pub tx_node_index: u32_,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct vnet_interface_per_thread_data_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub split_buffers: *mut u32_,
}
impl Default for vnet_interface_per_thread_data_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vnet_buffer_opquae_formatter_t =
    ::std::option::Option<unsafe extern "C" fn(b: *const vlib_buffer_t, s: *mut u8_) -> *mut u8_>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnet_interface_main_t {
    pub hw_interfaces: *mut vnet_hw_interface_t,
    pub hw_if_rx_queues: *mut vnet_hw_if_rx_queue_t,
    pub rxq_index_by_hw_if_index_and_queue_id: *mut uword,
    pub hw_if_tx_queues: *mut vnet_hw_if_tx_queue_t,
    pub txq_index_by_hw_if_index_and_queue_id: *mut uword,
    pub hw_interface_by_name: *mut uword,
    pub hw_interface_classes: *mut vnet_hw_interface_class_t,
    pub device_classes: *mut vnet_device_class_t,
    pub hw_interface_class_by_name: *mut uword,
    pub device_class_by_name: *mut uword,
    pub sw_interfaces: *mut vnet_sw_interface_t,
    pub sw_if_index_by_sup_and_sub: *mut uword,
    pub sw_if_counter_lock: clib_spinlock_t,
    pub sw_if_counters: *mut vlib_simple_counter_main_t,
    pub combined_sw_if_counters: *mut vlib_combined_counter_main_t,
    pub deleted_hw_interface_nodes: *mut vnet_hw_interface_nodes_t,
    pub pcap_drop_filter_hash: *mut uword,
    pub buffer_opaque_format_helpers: *mut vnet_buffer_opquae_formatter_t,
    pub buffer_opaque2_format_helpers: *mut vnet_buffer_opquae_formatter_t,
    pub per_thread_data: *mut vnet_interface_per_thread_data_t,
    pub output_feature_arc_index: u8_,
    pub hw_if_index_by_sw_if_index: *mut u32_,
    pub if_out_arc_end_next_index_by_sw_if_index: *mut u16_,
}
impl Default for vnet_interface_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const vnet_api_error_t_VNET_API_ERROR_UNSPECIFIED: vnet_api_error_t = -1;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_SW_IF_INDEX: vnet_api_error_t = -2;
pub const vnet_api_error_t_VNET_API_ERROR_NO_SUCH_FIB: vnet_api_error_t = -3;
pub const vnet_api_error_t_VNET_API_ERROR_NO_SUCH_INNER_FIB: vnet_api_error_t = -4;
pub const vnet_api_error_t_VNET_API_ERROR_NO_SUCH_LABEL: vnet_api_error_t = -5;
pub const vnet_api_error_t_VNET_API_ERROR_NO_SUCH_ENTRY: vnet_api_error_t = -6;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_VALUE: vnet_api_error_t = -7;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_VALUE_2: vnet_api_error_t = -8;
pub const vnet_api_error_t_VNET_API_ERROR_UNIMPLEMENTED: vnet_api_error_t = -9;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_SW_IF_INDEX_2: vnet_api_error_t = -10;
pub const vnet_api_error_t_VNET_API_ERROR_SYSCALL_ERROR_1: vnet_api_error_t = -11;
pub const vnet_api_error_t_VNET_API_ERROR_SYSCALL_ERROR_2: vnet_api_error_t = -12;
pub const vnet_api_error_t_VNET_API_ERROR_SYSCALL_ERROR_3: vnet_api_error_t = -13;
pub const vnet_api_error_t_VNET_API_ERROR_SYSCALL_ERROR_4: vnet_api_error_t = -14;
pub const vnet_api_error_t_VNET_API_ERROR_SYSCALL_ERROR_5: vnet_api_error_t = -15;
pub const vnet_api_error_t_VNET_API_ERROR_SYSCALL_ERROR_6: vnet_api_error_t = -16;
pub const vnet_api_error_t_VNET_API_ERROR_SYSCALL_ERROR_7: vnet_api_error_t = -17;
pub const vnet_api_error_t_VNET_API_ERROR_SYSCALL_ERROR_8: vnet_api_error_t = -18;
pub const vnet_api_error_t_VNET_API_ERROR_SYSCALL_ERROR_9: vnet_api_error_t = -19;
pub const vnet_api_error_t_VNET_API_ERROR_SYSCALL_ERROR_10: vnet_api_error_t = -20;
pub const vnet_api_error_t_VNET_API_ERROR_FEATURE_DISABLED: vnet_api_error_t = -30;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_REGISTRATION: vnet_api_error_t = -31;
pub const vnet_api_error_t_VNET_API_ERROR_NEXT_HOP_NOT_IN_FIB: vnet_api_error_t = -50;
pub const vnet_api_error_t_VNET_API_ERROR_UNKNOWN_DESTINATION: vnet_api_error_t = -51;
pub const vnet_api_error_t_VNET_API_ERROR_NO_PATHS_IN_ROUTE: vnet_api_error_t = -52;
pub const vnet_api_error_t_VNET_API_ERROR_NEXT_HOP_NOT_FOUND_MP: vnet_api_error_t = -53;
pub const vnet_api_error_t_VNET_API_ERROR_NO_MATCHING_INTERFACE: vnet_api_error_t = -54;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_VLAN: vnet_api_error_t = -55;
pub const vnet_api_error_t_VNET_API_ERROR_VLAN_ALREADY_EXISTS: vnet_api_error_t = -56;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_SRC_ADDRESS: vnet_api_error_t = -57;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_DST_ADDRESS: vnet_api_error_t = -58;
pub const vnet_api_error_t_VNET_API_ERROR_ADDRESS_LENGTH_MISMATCH: vnet_api_error_t = -59;
pub const vnet_api_error_t_VNET_API_ERROR_ADDRESS_NOT_FOUND_FOR_INTERFACE: vnet_api_error_t = -60;
pub const vnet_api_error_t_VNET_API_ERROR_ADDRESS_NOT_DELETABLE: vnet_api_error_t = -61;
pub const vnet_api_error_t_VNET_API_ERROR_IP6_NOT_ENABLED: vnet_api_error_t = -62;
pub const vnet_api_error_t_VNET_API_ERROR_NO_SUCH_NODE: vnet_api_error_t = -63;
pub const vnet_api_error_t_VNET_API_ERROR_NO_SUCH_NODE2: vnet_api_error_t = -64;
pub const vnet_api_error_t_VNET_API_ERROR_NO_SUCH_TABLE: vnet_api_error_t = -65;
pub const vnet_api_error_t_VNET_API_ERROR_NO_SUCH_TABLE2: vnet_api_error_t = -66;
pub const vnet_api_error_t_VNET_API_ERROR_NO_SUCH_TABLE3: vnet_api_error_t = -67;
pub const vnet_api_error_t_VNET_API_ERROR_SUBIF_ALREADY_EXISTS: vnet_api_error_t = -68;
pub const vnet_api_error_t_VNET_API_ERROR_SUBIF_CREATE_FAILED: vnet_api_error_t = -69;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_MEMORY_SIZE: vnet_api_error_t = -70;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_INTERFACE: vnet_api_error_t = -71;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_VLAN_TAG_COUNT: vnet_api_error_t = -72;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_ARGUMENT: vnet_api_error_t = -73;
pub const vnet_api_error_t_VNET_API_ERROR_UNEXPECTED_INTF_STATE: vnet_api_error_t = -74;
pub const vnet_api_error_t_VNET_API_ERROR_TUNNEL_EXIST: vnet_api_error_t = -75;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_DECAP_NEXT: vnet_api_error_t = -76;
pub const vnet_api_error_t_VNET_API_ERROR_RESPONSE_NOT_READY: vnet_api_error_t = -77;
pub const vnet_api_error_t_VNET_API_ERROR_NOT_CONNECTED: vnet_api_error_t = -78;
pub const vnet_api_error_t_VNET_API_ERROR_IF_ALREADY_EXISTS: vnet_api_error_t = -79;
pub const vnet_api_error_t_VNET_API_ERROR_BOND_SLAVE_NOT_ALLOWED: vnet_api_error_t = -80;
pub const vnet_api_error_t_VNET_API_ERROR_VALUE_EXIST: vnet_api_error_t = -81;
pub const vnet_api_error_t_VNET_API_ERROR_SAME_SRC_DST: vnet_api_error_t = -82;
pub const vnet_api_error_t_VNET_API_ERROR_IP6_MULTICAST_ADDRESS_NOT_PRESENT: vnet_api_error_t = -83;
pub const vnet_api_error_t_VNET_API_ERROR_SR_POLICY_NAME_NOT_PRESENT: vnet_api_error_t = -84;
pub const vnet_api_error_t_VNET_API_ERROR_NOT_RUNNING_AS_ROOT: vnet_api_error_t = -85;
pub const vnet_api_error_t_VNET_API_ERROR_ALREADY_CONNECTED: vnet_api_error_t = -86;
pub const vnet_api_error_t_VNET_API_ERROR_UNSUPPORTED_JNI_VERSION: vnet_api_error_t = -87;
pub const vnet_api_error_t_VNET_API_ERROR_IP_PREFIX_INVALID: vnet_api_error_t = -88;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_WORKER: vnet_api_error_t = -89;
pub const vnet_api_error_t_VNET_API_ERROR_LISP_DISABLED: vnet_api_error_t = -90;
pub const vnet_api_error_t_VNET_API_ERROR_CLASSIFY_TABLE_NOT_FOUND: vnet_api_error_t = -91;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_EID_TYPE: vnet_api_error_t = -92;
pub const vnet_api_error_t_VNET_API_ERROR_CANNOT_CREATE_PCAP_FILE: vnet_api_error_t = -93;
pub const vnet_api_error_t_VNET_API_ERROR_INCORRECT_ADJACENCY_TYPE: vnet_api_error_t = -94;
pub const vnet_api_error_t_VNET_API_ERROR_EXCEEDED_NUMBER_OF_RANGES_CAPACITY: vnet_api_error_t =
    -95;
pub const vnet_api_error_t_VNET_API_ERROR_EXCEEDED_NUMBER_OF_PORTS_CAPACITY: vnet_api_error_t = -96;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_ADDRESS_FAMILY: vnet_api_error_t = -97;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_SUB_SW_IF_INDEX: vnet_api_error_t = -98;
pub const vnet_api_error_t_VNET_API_ERROR_TABLE_TOO_BIG: vnet_api_error_t = -99;
pub const vnet_api_error_t_VNET_API_ERROR_CANNOT_ENABLE_DISABLE_FEATURE: vnet_api_error_t = -100;
pub const vnet_api_error_t_VNET_API_ERROR_BFD_EEXIST: vnet_api_error_t = -101;
pub const vnet_api_error_t_VNET_API_ERROR_BFD_ENOENT: vnet_api_error_t = -102;
pub const vnet_api_error_t_VNET_API_ERROR_BFD_EINUSE: vnet_api_error_t = -103;
pub const vnet_api_error_t_VNET_API_ERROR_BFD_NOTSUPP: vnet_api_error_t = -104;
pub const vnet_api_error_t_VNET_API_ERROR_ADDRESS_IN_USE: vnet_api_error_t = -105;
pub const vnet_api_error_t_VNET_API_ERROR_ADDRESS_NOT_IN_USE: vnet_api_error_t = -106;
pub const vnet_api_error_t_VNET_API_ERROR_QUEUE_FULL: vnet_api_error_t = -107;
pub const vnet_api_error_t_VNET_API_ERROR_APP_UNSUPPORTED_CFG: vnet_api_error_t = -108;
pub const vnet_api_error_t_VNET_API_ERROR_URI_FIFO_CREATE_FAILED: vnet_api_error_t = -109;
pub const vnet_api_error_t_VNET_API_ERROR_LISP_RLOC_LOCAL: vnet_api_error_t = -110;
pub const vnet_api_error_t_VNET_API_ERROR_BFD_EAGAIN: vnet_api_error_t = -111;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_GPE_MODE: vnet_api_error_t = -112;
pub const vnet_api_error_t_VNET_API_ERROR_LISP_GPE_ENTRIES_PRESENT: vnet_api_error_t = -113;
pub const vnet_api_error_t_VNET_API_ERROR_ADDRESS_FOUND_FOR_INTERFACE: vnet_api_error_t = -114;
pub const vnet_api_error_t_VNET_API_ERROR_SESSION_CONNECT: vnet_api_error_t = -115;
pub const vnet_api_error_t_VNET_API_ERROR_ENTRY_ALREADY_EXISTS: vnet_api_error_t = -116;
pub const vnet_api_error_t_VNET_API_ERROR_SVM_SEGMENT_CREATE_FAIL: vnet_api_error_t = -117;
pub const vnet_api_error_t_VNET_API_ERROR_APPLICATION_NOT_ATTACHED: vnet_api_error_t = -118;
pub const vnet_api_error_t_VNET_API_ERROR_BD_ALREADY_EXISTS: vnet_api_error_t = -119;
pub const vnet_api_error_t_VNET_API_ERROR_BD_IN_USE: vnet_api_error_t = -120;
pub const vnet_api_error_t_VNET_API_ERROR_BD_NOT_MODIFIABLE: vnet_api_error_t = -121;
pub const vnet_api_error_t_VNET_API_ERROR_BD_ID_EXCEED_MAX: vnet_api_error_t = -122;
pub const vnet_api_error_t_VNET_API_ERROR_SUBIF_DOESNT_EXIST: vnet_api_error_t = -123;
pub const vnet_api_error_t_VNET_API_ERROR_L2_MACS_EVENT_CLINET_PRESENT: vnet_api_error_t = -124;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_QUEUE: vnet_api_error_t = -125;
pub const vnet_api_error_t_VNET_API_ERROR_UNSUPPORTED: vnet_api_error_t = -126;
pub const vnet_api_error_t_VNET_API_ERROR_DUPLICATE_IF_ADDRESS: vnet_api_error_t = -127;
pub const vnet_api_error_t_VNET_API_ERROR_APP_INVALID_NS: vnet_api_error_t = -128;
pub const vnet_api_error_t_VNET_API_ERROR_APP_WRONG_NS_SECRET: vnet_api_error_t = -129;
pub const vnet_api_error_t_VNET_API_ERROR_APP_CONNECT_SCOPE: vnet_api_error_t = -130;
pub const vnet_api_error_t_VNET_API_ERROR_APP_ALREADY_ATTACHED: vnet_api_error_t = -131;
pub const vnet_api_error_t_VNET_API_ERROR_SESSION_REDIRECT: vnet_api_error_t = -132;
pub const vnet_api_error_t_VNET_API_ERROR_ILLEGAL_NAME: vnet_api_error_t = -133;
pub const vnet_api_error_t_VNET_API_ERROR_NO_NAME_SERVERS: vnet_api_error_t = -134;
pub const vnet_api_error_t_VNET_API_ERROR_NAME_SERVER_NOT_FOUND: vnet_api_error_t = -135;
pub const vnet_api_error_t_VNET_API_ERROR_NAME_RESOLUTION_NOT_ENABLED: vnet_api_error_t = -136;
pub const vnet_api_error_t_VNET_API_ERROR_NAME_SERVER_FORMAT_ERROR: vnet_api_error_t = -137;
pub const vnet_api_error_t_VNET_API_ERROR_NAME_SERVER_NO_SUCH_NAME: vnet_api_error_t = -138;
pub const vnet_api_error_t_VNET_API_ERROR_NAME_SERVER_NO_ADDRESSES: vnet_api_error_t = -139;
pub const vnet_api_error_t_VNET_API_ERROR_NAME_SERVER_NEXT_SERVER: vnet_api_error_t = -140;
pub const vnet_api_error_t_VNET_API_ERROR_APP_CONNECT_FILTERED: vnet_api_error_t = -141;
pub const vnet_api_error_t_VNET_API_ERROR_ACL_IN_USE_INBOUND: vnet_api_error_t = -142;
pub const vnet_api_error_t_VNET_API_ERROR_ACL_IN_USE_OUTBOUND: vnet_api_error_t = -143;
pub const vnet_api_error_t_VNET_API_ERROR_INIT_FAILED: vnet_api_error_t = -144;
pub const vnet_api_error_t_VNET_API_ERROR_NETLINK_ERROR: vnet_api_error_t = -145;
pub const vnet_api_error_t_VNET_API_ERROR_BIER_BSL_UNSUP: vnet_api_error_t = -146;
pub const vnet_api_error_t_VNET_API_ERROR_INSTANCE_IN_USE: vnet_api_error_t = -147;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_SESSION_ID: vnet_api_error_t = -148;
pub const vnet_api_error_t_VNET_API_ERROR_ACL_IN_USE_BY_LOOKUP_CONTEXT: vnet_api_error_t = -149;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_VALUE_3: vnet_api_error_t = -150;
pub const vnet_api_error_t_VNET_API_ERROR_NON_ETHERNET: vnet_api_error_t = -151;
pub const vnet_api_error_t_VNET_API_ERROR_BD_ALREADY_HAS_BVI: vnet_api_error_t = -152;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_PROTOCOL: vnet_api_error_t = -153;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_ALGORITHM: vnet_api_error_t = -154;
pub const vnet_api_error_t_VNET_API_ERROR_RSRC_IN_USE: vnet_api_error_t = -155;
pub const vnet_api_error_t_VNET_API_ERROR_KEY_LENGTH: vnet_api_error_t = -156;
pub const vnet_api_error_t_VNET_API_ERROR_FIB_PATH_UNSUPPORTED_NH_PROTO: vnet_api_error_t = -157;
pub const vnet_api_error_t_VNET_API_ERROR_API_ENDIAN_FAILED: vnet_api_error_t = -159;
pub const vnet_api_error_t_VNET_API_ERROR_NO_CHANGE: vnet_api_error_t = -160;
pub const vnet_api_error_t_VNET_API_ERROR_MISSING_CERT_KEY: vnet_api_error_t = -161;
pub const vnet_api_error_t_VNET_API_ERROR_LIMIT_EXCEEDED: vnet_api_error_t = -162;
pub const vnet_api_error_t_VNET_API_ERROR_IKE_NO_PORT: vnet_api_error_t = -163;
pub const vnet_api_error_t_VNET_API_ERROR_UDP_PORT_TAKEN: vnet_api_error_t = -164;
pub const vnet_api_error_t_VNET_API_ERROR_EAGAIN: vnet_api_error_t = -165;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_VALUE_4: vnet_api_error_t = -166;
pub const vnet_api_error_t_VNET_API_ERROR_BUSY: vnet_api_error_t = -167;
pub const vnet_api_error_t_VNET_API_ERROR_BUG: vnet_api_error_t = -168;
pub const vnet_api_error_t_VNET_API_ERROR_FEATURE_ALREADY_DISABLED: vnet_api_error_t = -169;
pub const vnet_api_error_t_VNET_API_ERROR_FEATURE_ALREADY_ENABLED: vnet_api_error_t = -170;
pub const vnet_api_error_t_VNET_API_ERROR_INVALID_PREFIX_LENGTH: vnet_api_error_t = -171;
pub const vnet_api_error_t_VNET_API_N_ERROR: vnet_api_error_t = -170;
pub type vnet_api_error_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vnet_ip_table_function_list_elt {
    pub next_ip_table_function: *mut _vnet_ip_table_function_list_elt,
    pub fp: ::std::option::Option<
        unsafe extern "C" fn(
            vnm: *mut vnet_main_t,
            table_id: u32_,
            flags: u32_,
        ) -> *mut clib_error_t,
    >,
}
impl Default for _vnet_ip_table_function_list_elt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _vnet_ip_table_function_list_elt_t = _vnet_ip_table_function_list_elt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnet_pcap_t {
    pub pcap_rx_enable: u8_,
    pub pcap_tx_enable: u8_,
    pub pcap_drop_enable: u8_,
    pub pcap_filter_enable: u8_,
    pub max_bytes_per_pkt: u32_,
    pub pcap_sw_if_index: u32_,
    pub pcap_main: pcap_main_t,
    pub filter_classify_table_index: u32_,
    pub current_filter_function: vlib_is_packet_traced_fn_t,
    pub pcap_error_index: vlib_error_t,
}
impl Default for vnet_pcap_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnet_main_t {
    pub local_interface_hw_if_index: u32_,
    pub local_interface_sw_if_index: u32_,
    pub interface_main: vnet_interface_main_t,
    pub device_class_registrations: *mut vnet_device_class_t,
    pub hw_interface_class_registrations: *mut vnet_hw_interface_class_t,
    pub hw_interface_add_del_functions: [*mut _vnet_interface_function_list_elt_t; 2usize],
    pub hw_interface_link_up_down_functions: [*mut _vnet_interface_function_list_elt_t; 2usize],
    pub sw_interface_add_del_functions: [*mut _vnet_interface_function_list_elt_t; 2usize],
    pub sw_interface_admin_up_down_functions: [*mut _vnet_interface_function_list_elt_t; 2usize],
    pub sw_interface_mtu_change_functions: [*mut _vnet_interface_function_list_elt_t; 2usize],
    pub interface_tag_by_sw_if_index: *mut uword,
    pub ip_table_add_del_functions: [*mut _vnet_ip_table_function_list_elt_t; 2usize],
    pub pcap: vnet_pcap_t,
    pub api_errno: vnet_api_error_t,
    pub vlib_main: *mut vlib_main_t,
}
impl Default for vnet_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn vnet_get_main() -> *mut vnet_main_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vnet_feature_arc_registration {
    pub next: *mut _vnet_feature_arc_registration,
    pub arc_name: *mut ::std::os::raw::c_char,
    pub start_nodes: *mut *mut ::std::os::raw::c_char,
    pub n_start_nodes: ::std::os::raw::c_int,
    pub last_in_arc: *mut ::std::os::raw::c_char,
    pub feature_arc_index: u8_,
    pub arc_index_ptr: *mut u8_,
}
impl Default for _vnet_feature_arc_registration {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vnet_feature_arc_registration_t = _vnet_feature_arc_registration;
pub type vnet_feature_enable_disable_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        sw_if_index: u32_,
        enable_disable: ::std::os::raw::c_int,
    ) -> *mut clib_error_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vnet_feature_registration {
    pub next: *mut _vnet_feature_registration,
    pub next_in_arc: *mut _vnet_feature_registration,
    pub arc_name: *mut ::std::os::raw::c_char,
    pub node_name: *mut ::std::os::raw::c_char,
    pub feature_index_ptr: *mut u32_,
    pub feature_index: u32_,
    pub runs_before: *mut *mut ::std::os::raw::c_char,
    pub runs_after: *mut *mut ::std::os::raw::c_char,
    pub enable_disable_cb: vnet_feature_enable_disable_function_t,
}
impl Default for _vnet_feature_registration {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vnet_feature_registration_t = _vnet_feature_registration;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vnet_feature_constraint_registration {
    pub next: *mut _vnet_feature_constraint_registration,
    pub next_in_arc: *mut _vnet_feature_constraint_registration,
    pub arc_name: *mut ::std::os::raw::c_char,
    pub feature_arc_index: u8_,
    pub node_names: *mut *mut ::std::os::raw::c_char,
}
impl Default for _vnet_feature_constraint_registration {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vnet_feature_constraint_registration_t = _vnet_feature_constraint_registration;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnet_feature_config_main_t_ {
    pub config_main: vnet_config_main_t,
    pub config_index_by_sw_if_index: *mut u32_,
}
impl Default for vnet_feature_config_main_t_ {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vnet_feature_config_main_t = vnet_feature_config_main_t_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnet_feature_main_t {
    pub next_arc: *mut vnet_feature_arc_registration_t,
    pub arc_index_by_name: *mut *mut uword,
    pub next_feature: *mut vnet_feature_registration_t,
    pub next_feature_by_arc: *mut *mut vnet_feature_registration_t,
    pub next_constraint: *mut vnet_feature_constraint_registration_t,
    pub next_constraint_by_arc: *mut *mut vnet_feature_constraint_registration_t,
    pub next_feature_by_name: *mut *mut uword,
    pub feature_config_mains: *mut vnet_feature_config_main_t,
    pub feature_nodes: *mut *mut *mut ::std::os::raw::c_char,
    pub sw_if_index_has_features: *mut *mut uword,
    pub feature_count_by_sw_if_index: *mut *mut i16_,
    pub device_input_feature_arc_index: u8_,
    pub vlib_main: *mut vlib_main_t,
    pub vnet_main: *mut vnet_main_t,
}
impl Default for vnet_feature_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub static mut feature_main: vnet_feature_main_t;
}
unsafe extern "C" {
    pub fn vnet_config_update_feature_count(
        fm: *mut vnet_feature_main_t,
        arc: u8_,
        sw_if_index: u32_,
        is_add: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vnet_get_feature_index(arc: u8_, s: *const ::std::os::raw::c_char) -> u32_;
}
unsafe extern "C" {
    pub fn vnet_get_feature_arc_index(s: *const ::std::os::raw::c_char) -> u8_;
}
unsafe extern "C" {
    pub fn vnet_get_feature_reg(
        arc_name: *const ::std::os::raw::c_char,
        node_name: *const ::std::os::raw::c_char,
    ) -> *mut vnet_feature_registration_t;
}
unsafe extern "C" {
    pub fn vnet_feature_enable_disable_with_index(
        arc_index: u8_,
        feature_index: u32_,
        sw_if_index: u32_,
        enable_disable: ::std::os::raw::c_int,
        feature_config: *mut ::std::os::raw::c_void,
        n_feature_config_bytes: u32_,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vnet_feature_enable_disable(
        arc_name: *const ::std::os::raw::c_char,
        node_name: *const ::std::os::raw::c_char,
        sw_if_index: u32_,
        enable_disable: ::std::os::raw::c_int,
        feature_config: *mut ::std::os::raw::c_void,
        n_feature_config_bytes: u32_,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vnet_feature_modify_end_node(
        arc_index: u8_,
        sw_if_index: u32_,
        node_index: u32_,
    ) -> u32_;
}
unsafe extern "C" {
    pub fn vnet_feature_get_end_node(arc_index: u8_, sw_if_index: u32_) -> u32_;
}
unsafe extern "C" {
    pub fn vnet_feature_reset_end_node(arc_index: u8_, sw_if_index: u32_) -> u32_;
}
unsafe extern "C" {
    pub fn vnet_feature_arc_init(
        vm: *mut vlib_main_t,
        vcm: *mut vnet_config_main_t,
        feature_start_nodes: *mut *mut ::std::os::raw::c_char,
        num_feature_start_nodes: ::std::os::raw::c_int,
        last_in_arc: *mut ::std::os::raw::c_char,
        first_reg: *mut vnet_feature_registration_t,
        first_const_set: *mut vnet_feature_constraint_registration_t,
        in_feature_nodes: *mut *mut *mut ::std::os::raw::c_char,
    ) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn vnet_interface_features_show(
        vm: *mut vlib_main_t,
        sw_if_index: u32_,
        verbose: ::std::os::raw::c_int,
    );
}
pub type vnet_feature_update_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        sw_if_index: u32_,
        arc_index: u8_,
        is_enable: u8_,
        cb: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    pub fn vnet_feature_register(cb: vnet_feature_update_cb_t, data: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn vnet_feature_is_enabled(
        arc_name: *const ::std::os::raw::c_char,
        feature_node_name: *const ::std::os::raw::c_char,
        sw_if_index: u32_,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Debug)]
pub struct vlib_plugin_registration_t {
    pub cacheline0: __IncompleteArrayField<u8_>,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub version: [::std::os::raw::c_char; 64usize],
    pub version_required: [::std::os::raw::c_char; 64usize],
    pub overrides: [::std::os::raw::c_char; 256usize],
    pub early_init: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
}
impl Default for vlib_plugin_registration_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl vlib_plugin_registration_t {
    #[inline]
    pub fn default_disabled(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_default_disabled(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn default_disabled_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_default_disabled_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn deep_bind(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_deep_bind(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn deep_bind_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_deep_bind_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        default_disabled: u8_,
        deep_bind: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let default_disabled: u8 = unsafe { ::std::mem::transmute(default_disabled) };
            default_disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let deep_bind: u8 = unsafe { ::std::mem::transmute(deep_bind) };
            deep_bind as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vlib_r2_string_t {
    pub data_segment_offset: uword,
    pub length: uword,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vlib_plugin_r2_t {
    pub default_disabled: ::std::os::raw::c_int,
    pub version: vlib_r2_string_t,
    pub version_required: vlib_r2_string_t,
    pub overrides: vlib_r2_string_t,
    pub early_init: vlib_r2_string_t,
    pub description: vlib_r2_string_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plugin_info_t {
    pub name: *mut u8_,
    pub filename: *mut u8_,
    pub file_info: stat,
    pub handle: *mut ::std::os::raw::c_void,
    pub reg: *mut vlib_plugin_registration_t,
    pub version: *mut ::std::os::raw::c_char,
}
impl Default for plugin_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plugin_config_t {
    pub name: *mut ::std::os::raw::c_char,
    pub is_disabled: u8_,
    pub is_enabled: u8_,
    pub skip_version_check: u8_,
}
impl Default for plugin_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct plugin_main_t {
    pub plugin_info: *mut plugin_info_t,
    pub plugin_by_name_hash: *mut uword,
    pub plugin_overrides_by_name_hash: *mut uword,
    pub plugin_path: *mut u8_,
    pub plugin_path_add: *mut u8_,
    pub plugin_name_filter: *mut u8_,
    pub vat_plugin_path: *mut u8_,
    pub vat_plugin_name_filter: *mut u8_,
    pub plugins_default_disable: u8_,
    pub configs: *mut plugin_config_t,
    pub config_index_by_name: *mut uword,
    pub logger: vlib_log_class_t,
    pub vlib_main: *mut vlib_main_t,
}
impl Default for plugin_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub static mut vlib_plugin_main: plugin_main_t;
}
unsafe extern "C" {
    pub fn vlib_plugin_config(
        vm: *mut vlib_main_t,
        input: *mut unformat_input_t,
    ) -> *mut clib_error_t;
}
unsafe extern "C" {
    pub fn vlib_plugin_early_init(vm: *mut vlib_main_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vlib_load_new_plugins(
        pm: *mut plugin_main_t,
        from_early_init: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vlib_get_plugin_symbol(
        plugin_name: *const ::std::os::raw::c_char,
        symbol_name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vlib_get_vat_plugin_path() -> *mut u8_;
}
pub const ip_dscp_t__IP_DSCP_CS0: ip_dscp_t_ = 0;
pub const ip_dscp_t__IP_DSCP_CS1: ip_dscp_t_ = 8;
pub const ip_dscp_t__IP_DSCP_AF11: ip_dscp_t_ = 10;
pub const ip_dscp_t__IP_DSCP_AF12: ip_dscp_t_ = 12;
pub const ip_dscp_t__IP_DSCP_AF13: ip_dscp_t_ = 14;
pub const ip_dscp_t__IP_DSCP_CS2: ip_dscp_t_ = 16;
pub const ip_dscp_t__IP_DSCP_AF21: ip_dscp_t_ = 18;
pub const ip_dscp_t__IP_DSCP_AF22: ip_dscp_t_ = 20;
pub const ip_dscp_t__IP_DSCP_AF23: ip_dscp_t_ = 22;
pub const ip_dscp_t__IP_DSCP_CS3: ip_dscp_t_ = 24;
pub const ip_dscp_t__IP_DSCP_AF31: ip_dscp_t_ = 26;
pub const ip_dscp_t__IP_DSCP_AF32: ip_dscp_t_ = 28;
pub const ip_dscp_t__IP_DSCP_AF33: ip_dscp_t_ = 30;
pub const ip_dscp_t__IP_DSCP_CS4: ip_dscp_t_ = 32;
pub const ip_dscp_t__IP_DSCP_AF41: ip_dscp_t_ = 34;
pub const ip_dscp_t__IP_DSCP_AF42: ip_dscp_t_ = 36;
pub const ip_dscp_t__IP_DSCP_AF43: ip_dscp_t_ = 38;
pub const ip_dscp_t__IP_DSCP_CS5: ip_dscp_t_ = 40;
pub const ip_dscp_t__IP_DSCP_EF: ip_dscp_t_ = 46;
pub const ip_dscp_t__IP_DSCP_CS6: ip_dscp_t_ = 48;
pub const ip_dscp_t__IP_DSCP_CS7: ip_dscp_t_ = 50;
pub type ip_dscp_t_ = ::std::os::raw::c_uchar;
pub use self::ip_dscp_t_ as ip_dscp_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip4_address_t {
    pub data: [u8_; 4usize],
    pub data_u32: u32_,
    pub as_u8: [u8_; 4usize],
    pub as_u16: [u16_; 2usize],
    pub as_u32: u32_,
}
impl Default for ip4_address_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip4_address_pair_t {
    pub src: ip4_address_t,
    pub dst: ip4_address_t,
}
impl Default for ip4_address_pair_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip4_header_t {
    pub __bindgen_anon_1: ip4_header_t__bindgen_ty_1,
    pub __bindgen_anon_2: ip4_header_t__bindgen_ty_2,
    pub __bindgen_anon_3: ip4_header_t__bindgen_ty_3,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ip4_header_t__bindgen_ty_1 {
    pub ip_version_and_header_length: u8_,
    pub tos: ip_dscp_t,
    pub length: u16_,
    pub fragment_id: u16_,
    pub flags_and_fragment_offset: u16_,
    pub ttl: u8_,
    pub protocol: u8_,
    pub checksum: u16_,
    pub __bindgen_anon_1: ip4_header_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip4_header_t__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: ip4_header_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub address_pair: ip4_address_pair_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip4_header_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub src_address: ip4_address_t,
    pub dst_address: ip4_address_t,
}
impl Default for ip4_header_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ip4_header_t__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ip4_header_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip4_header_t__bindgen_ty_2 {
    pub checksum_data_64: [u64_; 2usize],
    pub checksum_data_64_32: [u32_; 1usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip4_header_t__bindgen_ty_3 {
    pub checksum_data_32: [u32_; 5usize],
}
impl Default for ip4_header_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
pub struct ip6_header_t {
    pub ip_version_traffic_class_and_flow_label: u32_,
    pub payload_length: u16_,
    pub protocol: u8_,
    pub hop_limit: u8_,
    pub src_address: ip6_address_t,
    pub dst_address: ip6_address_t,
}
impl Default for ip6_header_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct svm_region_ {
    pub version: uword,
    pub mutex: pthread_mutex_t,
    pub condvar: pthread_cond_t,
    pub mutex_owner_pid: ::std::os::raw::c_int,
    pub mutex_owner_tag: ::std::os::raw::c_int,
    pub flags: uword,
    pub virtual_base: uword,
    pub virtual_size: uword,
    pub region_heap: *mut ::std::os::raw::c_void,
    pub data_base: *mut ::std::os::raw::c_void,
    pub data_heap: *mut ::std::os::raw::c_void,
    pub user_ctx: *mut ::std::os::raw::c_void,
    pub bitmap_size: uword,
    pub bitmap: *mut uword,
    pub region_name: *mut ::std::os::raw::c_char,
    pub backing_file: *mut ::std::os::raw::c_char,
    pub filenames: *mut *mut ::std::os::raw::c_char,
    pub client_pids: *mut uword,
}
impl Default for svm_region_ {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type svm_region_t = svm_region_;
#[repr(C)]
pub struct _svm_queue<FAM: ?Sized = [::std::os::raw::c_char; 0]> {
    pub mutex: pthread_mutex_t,
    pub condvar: pthread_cond_t,
    pub head: ::std::os::raw::c_int,
    pub tail: ::std::os::raw::c_int,
    pub cursize: ::std::os::raw::c_int,
    pub maxsize: ::std::os::raw::c_int,
    pub elsize: ::std::os::raw::c_int,
    pub consumer_pid: ::std::os::raw::c_int,
    pub producer_evtfd: ::std::os::raw::c_int,
    pub consumer_evtfd: ::std::os::raw::c_int,
    pub data: FAM,
}
impl _svm_queue<[::std::os::raw::c_char]> {}
impl _svm_queue<[::std::os::raw::c_char; 0]> {}
impl Default for _svm_queue<[::std::os::raw::c_char; 0]> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type svm_queue_t = _svm_queue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cJSON {
    pub next: *mut cJSON,
    pub prev: *mut cJSON,
    pub child: *mut cJSON,
    pub type_: ::std::os::raw::c_int,
    pub valuestring: *mut ::std::os::raw::c_char,
    pub valueint: ::std::os::raw::c_int,
    pub valuedouble: f64,
    pub string: *mut ::std::os::raw::c_char,
}
impl Default for cJSON {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const vl_registration_type_t_REGISTRATION_TYPE_FREE: vl_registration_type_t = 0;
pub const vl_registration_type_t_REGISTRATION_TYPE_SHMEM: vl_registration_type_t = 1;
pub const vl_registration_type_t_REGISTRATION_TYPE_SOCKET_LISTEN: vl_registration_type_t = 2;
pub const vl_registration_type_t_REGISTRATION_TYPE_SOCKET_SERVER: vl_registration_type_t = 3;
pub const vl_registration_type_t_REGISTRATION_TYPE_SOCKET_CLIENT: vl_registration_type_t = 4;
pub type vl_registration_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vl_api_registration_ {
    pub registration_type: vl_registration_type_t,
    pub vl_api_registration_pool_index: u32_,
    pub name: *mut u8_,
    pub last_heard: f64_,
    pub last_queue_head: ::std::os::raw::c_int,
    pub unanswered_pings: ::std::os::raw::c_int,
    pub is_being_removed: ::std::os::raw::c_int,
    pub vl_input_queue: *mut svm_queue_t,
    pub vlib_rp: *mut svm_region_t,
    pub shmem_hdr: *mut ::std::os::raw::c_void,
    pub clib_file_index: u32_,
    pub unprocessed_input: *mut i8_,
    pub unprocessed_msg_length: u32_,
    pub output_vector: *mut u8_,
    pub additional_fds_to_close: *mut ::std::os::raw::c_int,
    pub server_handle: u32_,
    pub server_index: u32_,
    pub keepalive: bool,
}
impl Default for vl_api_registration_ {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vl_api_registration_t = vl_api_registration_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vl_api_trace_t {
    pub endian: u8_,
    pub enabled: u8_,
    pub wrapped: u8_,
    pub pad: u8_,
    pub nitems: u32_,
    pub curindex: u32_,
    pub traces: *mut *mut u8_,
}
impl Default for vl_api_trace_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const vl_api_trace_which_t_VL_API_TRACE_TX: vl_api_trace_which_t = 0;
pub const vl_api_trace_which_t_VL_API_TRACE_RX: vl_api_trace_which_t = 1;
pub type vl_api_trace_which_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vl_api_msg_range_t {
    pub name: *mut u8_,
    pub first_msg_id: u16_,
    pub last_msg_id: u16_,
}
impl Default for vl_api_msg_range_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vl_msg_api_msg_config_t {
    pub id: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub crc: u32_,
    pub handler: *mut ::std::os::raw::c_void,
    pub cleanup: *mut ::std::os::raw::c_void,
    pub endian: *mut ::std::os::raw::c_void,
    pub format_fn: *mut ::std::os::raw::c_void,
    pub tojson: *mut ::std::os::raw::c_void,
    pub fromjson: *mut ::std::os::raw::c_void,
    pub calc_size: *mut ::std::os::raw::c_void,
    pub size: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for vl_msg_api_msg_config_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl vl_msg_api_msg_config_t {
    #[inline]
    pub fn traced(&self) -> u32_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_traced(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn traced_raw(this: *const Self) -> u32_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_traced_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn replay(&self) -> u32_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_replay(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn replay_raw(this: *const Self) -> u32_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_replay_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn message_bounce(&self) -> u32_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_message_bounce(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn message_bounce_raw(this: *const Self) -> u32_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_message_bounce_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_mp_safe(&self) -> u32_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_mp_safe(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_mp_safe_raw(this: *const Self) -> u32_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_mp_safe_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_autoendian(&self) -> u32_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_autoendian(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_autoendian_raw(this: *const Self) -> u32_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_autoendian_raw(this: *mut Self, val: u32_) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        traced: u32_,
        replay: u32_,
        message_bounce: u32_,
        is_mp_safe: u32_,
        is_autoendian: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let traced: u32 = unsafe { ::std::mem::transmute(traced) };
            traced as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let replay: u32 = unsafe { ::std::mem::transmute(replay) };
            replay as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let message_bounce: u32 = unsafe { ::std::mem::transmute(message_bounce) };
            message_bounce as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_mp_safe: u32 = unsafe { ::std::mem::transmute(is_mp_safe) };
            is_mp_safe as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_autoendian: u32 = unsafe { ::std::mem::transmute(is_autoendian) };
            is_autoendian as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct msgbuf_<FAM: ?Sized = [u8_; 0]> {
    pub q: *mut svm_queue_t,
    pub data_len: u32_,
    pub gc_mark_timestamp: u32_,
    pub data: FAM,
}
impl msgbuf_<[u8_]> {}
impl msgbuf_<[u8_; 0]> {}
impl Default for msgbuf_<[u8_; 0]> {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type msgbuf_t = msgbuf_;
unsafe extern "C" {
    pub fn vl_msg_api_handler(the_msg: *mut ::std::os::raw::c_void, msg_len: uword);
}
unsafe extern "C" {
    pub fn vl_msg_api_handler_no_free(the_msg: *mut ::std::os::raw::c_void, msg_len: uword);
}
unsafe extern "C" {
    pub fn vl_msg_api_handler_no_trace_no_free(
        the_msg: *mut ::std::os::raw::c_void,
        msg_len: uword,
    );
}
unsafe extern "C" {
    pub fn vl_msg_api_trace_only(the_msg: *mut ::std::os::raw::c_void, msg_len: uword);
}
unsafe extern "C" {
    pub fn vl_msg_api_cleanup_handler(the_msg: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn vl_msg_api_replay_handler(the_msg: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn vl_msg_api_socket_handler(the_msg: *mut ::std::os::raw::c_void, msg_len: uword);
}
unsafe extern "C" {
    pub fn vl_msg_api_clean_handlers(msg_id: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn vl_msg_api_config(arg1: *mut vl_msg_api_msg_config_t);
}
unsafe extern "C" {
    pub fn vl_msg_api_set_cleanup_handler(
        msg_id: ::std::os::raw::c_int,
        fp: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn vl_msg_api_queue_handler(q: *mut svm_queue_t);
}
unsafe extern "C" {
    pub fn vl_msg_api_barrier_sync();
}
unsafe extern "C" {
    pub fn vl_msg_api_barrier_release();
}
unsafe extern "C" {
    pub fn vl_msg_api_free(arg1: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn vl_msg_api_increment_missing_client_counter();
}
unsafe extern "C" {
    pub fn vl_msg_api_post_mortem_dump();
}
unsafe extern "C" {
    pub fn vl_msg_api_post_mortem_dump_enable_disable(enable: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn vl_msg_api_register_pd_handler(
        handler: *mut ::std::os::raw::c_void,
        msg_id_host_byte_order: u16_,
    );
}
unsafe extern "C" {
    pub fn vl_msg_api_set_first_available_msg_id(first_avail: u16_);
}
unsafe extern "C" {
    pub fn vl_msg_api_get_msg_ids(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    ) -> u16_;
}
unsafe extern "C" {
    pub fn vl_msg_api_get_msg_index(name_and_crc: *mut u8_) -> u32_;
}
unsafe extern "C" {
    pub fn vl_msg_push_heap() -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vl_msg_push_heap_w_region(vlib_rp: *mut svm_region_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vl_msg_pop_heap(oldheap: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn vl_msg_pop_heap_w_region(
        vlib_rp: *mut svm_region_t,
        oldheap: *mut ::std::os::raw::c_void,
    );
}
pub type vl_msg_api_init_function_t =
    ::std::option::Option<unsafe extern "C" fn(client_index: u32_) -> *mut clib_error_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _vl_msg_api_init_function_list_elt {
    pub next_init_function: *mut _vl_msg_api_init_function_list_elt,
    pub f: vl_msg_api_init_function_t,
}
impl Default for _vl_msg_api_init_function_list_elt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _vl_msg_api_function_list_elt_t = _vl_msg_api_init_function_list_elt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct api_version_t {
    pub major: u32_,
    pub minor: u32_,
    pub patch: u32_,
    pub name: [::std::os::raw::c_char; 64usize],
}
impl Default for api_version_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vl_api_msg_data_t {
    pub handler: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub cleanup_handler:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub name: *const ::std::os::raw::c_char,
    pub format_fn: format_function_t,
    pub tojson_handler: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut cJSON,
    >,
    pub fromjson_handler: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut cJSON,
            arg2: *mut ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub endian_handler: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, to_net: bool),
    >,
    pub calc_size_func:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> uword>,
    pub trace_size: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for vl_api_msg_data_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl vl_api_msg_data_t {
    #[inline]
    pub fn bounce(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bounce(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bounce_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_bounce_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_mp_safe(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_mp_safe(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_mp_safe_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_mp_safe_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_autoendian(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_autoendian(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_autoendian_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_is_autoendian_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn trace_enable(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_trace_enable(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn trace_enable_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_trace_enable_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn replay_allowed(&self) -> u8_ {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_replay_allowed(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn replay_allowed_raw(this: *const Self) -> u8_ {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_replay_allowed_raw(this: *mut Self, val: u8_) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bounce: u8_,
        is_mp_safe: u8_,
        is_autoendian: u8_,
        trace_enable: u8_,
        replay_allowed: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bounce: u8 = unsafe { ::std::mem::transmute(bounce) };
            bounce as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_mp_safe: u8 = unsafe { ::std::mem::transmute(is_mp_safe) };
            is_mp_safe as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_autoendian: u8 = unsafe { ::std::mem::transmute(is_autoendian) };
            is_autoendian as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let trace_enable: u8 = unsafe { ::std::mem::transmute(trace_enable) };
            trace_enable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let replay_allowed: u8 = unsafe { ::std::mem::transmute(replay_allowed) };
            replay_allowed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct api_main_t {
    pub msg_data: *mut vl_api_msg_data_t,
    pub msg_id_by_name: *mut uword,
    pub arings: *mut ring_alloc_,
    pub ring_misses: u32_,
    pub garbage_collects: u32_,
    pub missing_clients: u32_,
    pub rx_trace: *mut vl_api_trace_t,
    pub tx_trace: *mut vl_api_trace_t,
    pub msg_print_flag: ::std::os::raw::c_int,
    pub our_pid: ::std::os::raw::c_int,
    pub vlib_rp: *mut svm_region_t,
    pub vlib_primary_rp: *mut svm_region_t,
    pub vlib_private_rps: *mut *mut svm_region_t,
    pub mapped_shmem_regions: *mut *mut svm_region_t,
    pub shmem_hdr: *mut vl_shmem_hdr_,
    pub vl_clients: *mut *mut vl_api_registration_t,
    pub serialized_message_table_in_shmem: *mut u8_,
    pub first_available_msg_id: u16_,
    pub msg_range_by_name: *mut uword,
    pub msg_ranges: *mut vl_api_msg_range_t,
    pub api_uid: ::std::os::raw::c_int,
    pub api_gid: ::std::os::raw::c_int,
    pub global_baseva: u64_,
    pub global_size: u64_,
    pub api_size: u64_,
    pub global_pvt_heap_size: u64_,
    pub api_pvt_heap_size: u64_,
    pub vl_input_queue: *mut svm_queue_t,
    pub my_client_index: ::std::os::raw::c_int,
    pub my_registration: *mut vl_api_registration_t,
    pub vlib_input_queue_length: u32_,
    pub msg_index_by_name_and_crc: *mut uword,
    pub json_api_repr: *mut *mut u8_,
    pub api_version_list: *mut api_version_t,
    pub region_name: *const ::std::os::raw::c_char,
    pub root_path: *const ::std::os::raw::c_char,
    pub replay_in_progress: ::std::os::raw::c_int,
    pub save_msg_table_filename: *mut u8_,
    pub reaper_function_registrations: *mut _vl_msg_api_function_list_elt_t,
    pub rx_thread_handle: pthread_t,
    pub elog_main: *mut elog_main_t,
    pub elog_trace_api_messages: ::std::os::raw::c_int,
    pub perf_counter_cbs: *mut ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut api_main_t,
            id: u32_,
            before_or_after: ::std::os::raw::c_int,
        ),
    >,
    pub perf_counter_cbs_tmp: *mut ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut api_main_t,
            id: u32_,
            before_or_after: ::std::os::raw::c_int,
        ),
    >,
}
impl Default for api_main_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub static mut my_api_main: *mut api_main_t;
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vl_api_trace_file_header_t {
    pub nitems: u32_,
    pub msgtbl_size: u32_,
    pub wrapped: u8_,
}
unsafe extern "C" {
    pub fn vl_msg_api_trace_save(
        am: *mut api_main_t,
        which: vl_api_trace_which_t,
        fp: *mut FILE,
        is_json: u8_,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vl_msg_api_rx_trace_enabled(am: *mut api_main_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vl_msg_api_tx_trace_enabled(am: *mut api_main_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vl_msg_api_trace(
        am: *mut api_main_t,
        tp: *mut vl_api_trace_t,
        msg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn vl_msg_api_trace_onoff(
        am: *mut api_main_t,
        which: vl_api_trace_which_t,
        onoff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vl_msg_api_trace_free(
        am: *mut api_main_t,
        which: vl_api_trace_which_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vl_msg_api_trace_configure(
        am: *mut api_main_t,
        which: vl_api_trace_which_t,
        nitems: u32_,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vl_msg_api_max_length(mp: *mut ::std::os::raw::c_void) -> u32_;
}
unsafe extern "C" {
    pub fn vl_msg_api_trace_get(
        am: *mut api_main_t,
        which: vl_api_trace_which_t,
    ) -> *mut vl_api_trace_t;
}
unsafe extern "C" {
    pub fn vl_msg_api_add_msg_name_crc(
        am: *mut api_main_t,
        string: *const ::std::os::raw::c_char,
        id: u32_,
    );
}
unsafe extern "C" {
    pub fn vl_msg_api_add_version(
        am: *mut api_main_t,
        string: *const ::std::os::raw::c_char,
        major: u32_,
        minor: u32_,
        patch: u32_,
    );
}
unsafe extern "C" {
    pub fn vlib_node_serialize(
        vm: *mut vlib_main_t,
        node_dups: *mut *mut *mut vlib_node_t,
        vector: *mut u8_,
        include_nexts: ::std::os::raw::c_int,
        include_stats: ::std::os::raw::c_int,
    ) -> *mut u8_;
}
unsafe extern "C" {
    pub fn vlib_node_unserialize(vector: *mut u8_) -> *mut *mut *mut vlib_node_t;
}
unsafe extern "C" {
    pub fn vl_msg_api_get_msg_length(msg_arg: *mut ::std::os::raw::c_void) -> u32_;
}
pub type vl_msg_traverse_trace_fn = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut u8_,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn vl_msg_traverse_trace(
        tp: *mut vl_api_trace_t,
        fn_: vl_msg_traverse_trace_fn,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn format_vl_api_msg_text(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
unsafe extern "C" {
    pub fn format_vl_api_msg_json(s: *mut u8_, args: *mut va_list) -> *mut u8_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ring_alloc_ {
    pub rp: *mut svm_queue_t,
    pub size: u16_,
    pub nitems: u16_,
    pub hits: u32_,
    pub misses: u32_,
}
impl Default for ring_alloc_ {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ring_alloc_t = ring_alloc_;
pub const vl_api_shm_config_type_t_VL_API_VLIB_RING: vl_api_shm_config_type_t = 0;
pub const vl_api_shm_config_type_t_VL_API_CLIENT_RING: vl_api_shm_config_type_t = 1;
pub const vl_api_shm_config_type_t_VL_API_QUEUE: vl_api_shm_config_type_t = 2;
pub type vl_api_shm_config_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vl_api_shm_elem_config_ {
    pub type_: u8_,
    pub _pad: u8_,
    pub count: u16_,
    pub size: u32_,
}
pub type vl_api_shm_elem_config_t = vl_api_shm_elem_config_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vl_shmem_hdr_ {
    pub version: ::std::os::raw::c_int,
    pub vl_pid: ::std::os::raw::c_int,
    pub vl_input_queue: *mut svm_queue_t,
    pub vl_rings: *mut ring_alloc_t,
    pub client_rings: *mut ring_alloc_t,
    pub application_restarts: u32_,
    pub restart_reclaims: u32_,
    pub garbage_collects: u32_,
    pub clib_file_index: u32_,
}
impl Default for vl_shmem_hdr_ {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vl_shmem_hdr_t = vl_shmem_hdr_;
unsafe extern "C" {
    pub fn vl_msg_api_alloc(nbytes: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vl_msg_api_alloc_zero(nbytes: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vl_msg_api_alloc_or_null(nbytes: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vl_msg_api_alloc_as_if_client(
        nbytes: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vl_msg_api_alloc_zero_as_if_client(
        nbytes: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vl_msg_api_alloc_as_if_client_or_null(
        nbytes: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vl_mem_api_alloc_as_if_client_w_reg(
        reg: *mut vl_api_registration_t,
        nbytes: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vl_msg_api_free_w_region(vlib_rp: *mut svm_region_t, a: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn vl_map_shmem(
        region_name: *const ::std::os::raw::c_char,
        is_vlib: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vl_unmap_shmem();
}
unsafe extern "C" {
    pub fn vl_unmap_shmem_client();
}
unsafe extern "C" {
    pub fn vl_register_mapped_shmem_region(rp: *mut svm_region_t);
}
unsafe extern "C" {
    pub fn vl_msg_api_send_shmem(q: *mut svm_queue_t, elem: *mut u8_);
}
unsafe extern "C" {
    pub fn vl_mem_api_can_send(q: *mut svm_queue_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vl_set_memory_region_name(name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn vl_set_memory_root_path(root_path: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn vl_set_memory_uid(uid: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn vl_set_memory_gid(gid: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn vl_set_global_memory_baseva(baseva: u64_);
}
unsafe extern "C" {
    pub fn vl_set_global_memory_size(size: u64_);
}
unsafe extern "C" {
    pub fn vl_set_api_memory_size(size: u64_);
}
unsafe extern "C" {
    pub fn vl_set_global_pvt_heap_size(size: u64_);
}
unsafe extern "C" {
    pub fn vl_set_api_pvt_heap_size(size: u64_);
}
unsafe extern "C" {
    pub fn vl_init_shmem(
        vlib_rp: *mut svm_region_t,
        config: *mut vl_api_shm_elem_config_t,
        is_vlib: ::std::os::raw::c_int,
        is_private_region: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vlib_helper_get_global_main() -> *mut vlib_global_main_t;
}
unsafe extern "C" {
    pub fn vlib_helper_remove_node_from_registrations(
        vgm: *mut vlib_global_main_t,
        node: *mut vlib_node_registration_t,
    );
}
unsafe extern "C" {
    pub fn vlib_helper_remove_feature_from_registrations(
        fm: *mut vnet_feature_main_t,
        r: *mut vnet_feature_registration_t,
    );
}
unsafe extern "C" {
    pub fn vlib_helper_remove_cli_command(cm: *mut vlib_cli_main_t, x: *mut vlib_cli_command_t);
}
unsafe extern "C" {
    pub fn vlib_helper_buffer_alloc(
        vm: *mut vlib_main_t,
        buffers: *mut u32_,
        n_buffers: u32_,
    ) -> u32_;
}
unsafe extern "C" {
    pub fn vlib_helper_buffer_free(vm: *mut vlib_main_t, buffers: *mut u32_, n_buffers: u32_);
}
unsafe extern "C" {
    pub fn vlib_helper_format_vnet_sw_if_index_name(s: *mut u8_, ...) -> *mut u8_;
}
unsafe extern "C" {
    pub fn vlib_helper_unformat_vnet_sw_interface(input: *mut unformat_input_t, ...) -> uword;
}
unsafe extern "C" {
    pub fn vlib_helper_format_ip4_header(s: *mut u8_, ...) -> *mut u8_;
}
unsafe extern "C" {
    pub fn vlib_helper_format_ip6_header(s: *mut u8_, ...) -> *mut u8_;
}
unsafe extern "C" {
    pub fn vlib_helper_feature_next_with_data(
        next0: *mut u32_,
        b0: *mut vlib_buffer_t,
        n_data_bytes: u32_,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vlib_helper_unformat_get_input(input: *mut unformat_input_t) -> uword;
}
unsafe extern "C" {
    pub fn vlib_helper_unformat_free(input: *mut unformat_input_t);
}
unsafe extern "C" {
    pub fn vl_api_helper_client_index_to_registration(index: u32_) -> *mut vl_api_registration_t;
}
unsafe extern "C" {
    pub fn vlibapi_helper_get_main() -> *mut api_main_t;
}
unsafe extern "C" {
    pub fn vl_api_helper_send_msg(rp: *mut vl_api_registration_t, elem: *mut u8_);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
